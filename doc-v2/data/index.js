var Pages = [["domiterator","DOMIterator class"],["elements-boundaries","Elements boundaries"],["filtering-matches","Filtering matches"],["getting-started","Getting started"],["index","Content"],["mark-lines","Highlighting line ranges"],["mark-method","mark() method"],["mark","Mark class"],["markRanges-method","markRanges() method"],["markRegExp-method","markRegExp() method"],["nesting-overlapping","Nesting/overlapping ranges and match groups"],["options","Options descriptions"],["performance","Performance"],["RegExpCreator-module","RegExpCreator module"],["regexpcreator","RegExpCreator class"],["separate-groups","Highlighting separate groups"],["shadow-dom","Highlighting in shadow DOM"],["some-examples","Code examples of using each and done callbacks"],["TypeScript-types","TypeScript types"],["unmark-method","unmark() method"]];
var Headers = {"0":[["DOMIterator class","6","domiterator-class"]],"1":[["Elements boundaries","5","elements-boundaries"],["Boundary object:","3","boundary-object"],["Example:","4","example"],["Extending default block elements with custom elements:","4","extending-default-block-elements-with-custom-elements"]],"2":[["Filtering matches","5","filtering-matches"],["To filter matches in the mark() method with acrossElements option","3","to-filter-matches-in-the-mark-method-with-acrosselements-option"],["To filter matches in the mark() method without acrossElements option","3","to-filter-matches-in-the-mark-method-without-acrosselements-option"],["To filter matches in the markRegExp() method","3","to-filter-matches-in-the-markregexp-method"],["Mark the first desired number of matches on each callback using acrossElements option.","3","mark-the-first-desired-number-of-matches-on-each-callback-using-acrosselements-option"]],"3":[["Getting started","5","getting-started"],["HTML","4","html"],["API","4","api"],["JavaScript","3","javascript"],["jQuery","3","jquery"]],"4":[["Content","5","1111"]],"5":[["Highlighting line ranges","5","highlighting-line-ranges"],["Highlight and scroll into view the specified code line:","3","highlight-and-scroll-into-view-the-specified-code-line"]],"6":[["mark() method","5","mark-method"],["Syntax","4","syntax"],["Parameters:","3","parameters"],["Available properties of the filterInfo object depending on options","4","available-properties-of-the-filterinfo-object-depending-on-options"],["Available properties of the eachInfo object depending on options","4","available-properties-of-the-eachinfo-object-depending-on-options"]],"7":[["Mark class","6","mark-class"]],"8":[["markRanges() method","5","markranges-method"],["Syntax","4","syntax"],["Parameters:","3","parameters"]],"9":[["markRegExp() method","5","markregexp-method"],["Syntax","4","syntax"],["Parameters:","3","parameters"],["Available properties of the filterInfo object depending on options","4","available-properties-of-the-filterinfo-object-depending-on-options"],["Available properties of the eachInfo object depending on options","4","available-properties-of-the-eachinfo-object-depending-on-options"]],"10":[["Nesting/overlapping ranges and match groups","5","nestingoverlapping-ranges-and-match-groups"],["To mark nesting/overlapping ranges.","3","to-mark-nestingoverlapping-ranges"],["To mark nesting groups with acrossElements option and d flag.","3","to-mark-nesting-groups-with-acrosselements-option-and-d-flag"],["To mark nesting groups with acrossElements option and RegExp without d flag","3","mark-nesting-groups"],["Simple example with next/previous buttons.","3","simple-example-with-nextprevious-buttons"]],"11":[["Options descriptions","5","options-descriptions"],["acrossElements option","4","acrosselements-option"],["separateWordSearch option","4","separatewordsearch-option"],["exclude option","4","exclude-option"],["accuracy option","4","accuracy-option"]],"12":[["Performance","5","performance"],["The performance results in Firefox compare to mark.js v8.11.1:","4","the-performance-results-in-firefox-compare-to-mark.js-v8.11.1"],["Ways to boost performance","4","ways-to-boost-performance"]],"13":[["RegExpCreator module","5","regexpcreator-module"],["create()","3","create"],["createCombinePattern()","3","createcombinepattern"],["createDiacritics()","3","creatediacritics"]],"14":[["RegExpCreator class","6","regexpcreator-class"]],"15":[["Highlighting separate groups","5","highlighting-separate-groups"],["Filtering capturing groups:","3","filtering-capturing-groups"],["Example to mark separate groups with acrossElements option:","3","example-to-mark-separate-groups-with-acrosselements-option"],["Example to mark separate groups without acrossElements option:","3","example-to-mark-separate-groups-without-acrosselements-option"]],"16":[["Highlighting in shadow DOM","5","highlighting-in-shadow-dom"]],"17":[["Code examples of using each and done callbacks","5","code-examples-of-using-each-and-done-callbacks"],["In mark() method with acrossElements option","3","in-mark-method-with-acrosselements-option"],["In mark() method without acrossElements option","3","in-mark-method-without-acrosselements-option"],["In markRegExp() method with acrossElements option","3","in-markregexp-method-with-acrosselements-option"],["Simple example with next/previous buttons","3","simple-example-with-nextprevious-buttons"]],"18":[["TypeScript types","5","typescript-types"],["JavaScript example","3","javascript-example"],["jQuery example","3","jquery-example"]],"19":[["unmark() method","5","unmark-method"],["Syntax","4","syntax"],["Parameters:","3","parameters"]]};
var Common = {"a":1,"also":1,"an":1,"and":1,"are":1,"as":1,"at":1,"be":1,"by":1,"can":1,"for":1,"from":1,"get":1,"if":1,"in":1,"is":1,"it":1,"none":1,"not":1,"of":1,"on":1,"only":1,"or":1,"see":1,"set":1,"that":1,"the":1,"this":1,"to":1,"use":1,"used":1,"when":1,"will":1,"with":1,"you":1};
var Info = [["DOMIterator class∎/** * A NodeIterator with iframes support and a method to check if an element is * matching a specified selector * @example * const iterator = new DOMIterator( * document.querySelector(&quot;#context&quot;), true * ); * iterator.forEachNode(NodeFilter.SHOW_TEXT, node =&gt; { // each * console.log(node); * }, node =&gt; { // filter * return !DOMIterator.matches(node.parentNode, &quot;.ignore&quot;); * }, () =&gt; { * console.log(&quot;DONE&quot;); * }); */ class DOMIterator { /** * @param {HTMLElement|HTMLElement[]|NodeList|string} ctx - The context DOM * element, an array of DOM elements, a NodeList or a selector * @param {object} opt - Options object */ constructor(ctx, opt) { /** * The context of the instance. Either a DOM element, an array of DOM * elements, a NodeList or a selector * @type {HTMLElement|HTMLElement[]|NodeList|string} * @access protected */ this.ctx = ctx; /** * The object containing Mark options * @type {object} * @access protected */ this.opt = opt; /** * The name of an attribute, which added to iframes, to indicate iframe state * @type {string} * @access protected */ this.attrName = 'data-markjsListener'; } /** * Checks if the specified DOM element matches the selector * @param {HTMLElement} element - The DOM element * @param {string|string[]} selector - The selector or an array with * selectors * @return {boolean} * @access public */ static matches(element, selector) { if ( !selector || !selector.length) { return false; } const selectors = typeof selector === 'string' ? [selector] : selector; const fn = ( element.matches || element.matchesSelector || element.msMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector || element.webkitMatchesSelector ); return fn &amp;&amp; selectors.some(sel =&gt; fn.call(element, sel)); } /** * Returns all contexts filtered by duplicates or nested elements * @return {HTMLElement[]} - An array containing DOM contexts * @access protected */ getContexts() { let ctx = this.ctx, sort = false; if ( !ctx) return []; if ( !this.opt.window.NodeList.prototype.isPrototypeOf(ctx)) { if (Array.isArray(ctx)) { sort = true; } else if (typeof ctx === 'string') { ctx = this.opt.window.document.querySelectorAll(ctx); } else { // e.g. HTMLElement or element inside iframe ctx = [ctx]; } } // filters out duplicate/nested elements const array = []; ctx.forEach(elem =&gt; { if (array.indexOf(elem) === -1 &amp;&amp; !array.some(node =&gt; node.contains(elem))) { array.push(elem); } }); // elements in the custom array can be in any order // sorts elements by the DOM order if (sort) { array.sort((a, b) =&gt; { return (a.compareDocumentPosition(b) &amp; this.opt.window.Node.DOCUMENT_POSITION_FOLLOWING) &gt; 0 ? -1 : 1; }); } return array; } /** * @callback DOMIterator~getIframeContentsSuccessCallback * @param {HTMLDocument} contents - The contentDocument of the iframe */ /** * Calls the success callback function with the iframe document. If it can't * be accessed it calls the error callback function * @param {HTMLElement} ifr - The iframe DOM element * @param {DOMIterator~getIframeContentsSuccessCallback} successFn * @param {function} [errorFn] * @access protected */ getIframeContents(iframe, successFn, errorFn) { try { const doc = iframe.contentWindow.document; if (doc) { iframe.setAttribute(this.attrName, 'completed'); successFn({ iframe : iframe, context : doc }); } } catch (e) { iframe.setAttribute(this.attrName, 'error'); errorFn({ iframe : iframe, error : e }); } } /** * Checks if an iframe is empty (if about:blank is the shown page) * @param {HTMLElement} ifr - The iframe DOM element * @return {boolean} * @access protected */ isIframeBlank(ifr) { const bl = 'about:blank', src = ifr.getAttribute('src').trim(), href = ifr.contentWindow.location.href; return href === bl &amp;&amp; src !== bl &amp;&amp; src; } /** * Observes the onload event of an iframe and calls the success callback or * the error callback if the iframe is inaccessible. If the event isn't * fired within the specified {@link DOMIterator#iframesTimeout}, then it'll * call the error callback too * @param {HTMLElement} ifr - The iframe DOM element * @param {DOMIterator~getIframeContentsSuccessCallback} successFn * @param {function} errorFn * @access protected */ observeIframeLoad(ifr, successFn, errorFn) { // an event listener is already added to the iframe if (ifr.hasAttribute(this.attrName)) { return; } let id = null; const listener = () =&gt; { clearTimeout(id); ifr.removeEventListener('load', listener); this.getIframeContents(ifr, successFn, errorFn); }; ifr.addEventListener('load', listener); ifr.setAttribute(this.attrName, true); id = setTimeout(listener, this.opt.iframesTimeout); } /** * Callback when the iframe is ready * @callback DOMIterator~onIframeReadySuccessCallback * @param {HTMLDocument} contents - The contentDocument of the iframe */ /** * Callback if the iframe can't be accessed * @callback DOMIterator~onIframeReadyErrorCallback */ /** * Calls the callback if the specified iframe is ready for DOM access * @param {HTMLElement} ifr - The iframe DOM element * @param {DOMIterator~onIframeReadySuccessCallback} successFn - Success * callback * @param {DOMIterator~onIframeReadyErrorCallback} errorFn - Error callback * @see {@link http://stackoverflow.com/a/36155560/3894981} for * background information * @access protected */ onIframeReady(ifr, successFn, errorFn) { try { if (ifr.contentWindow.document.readyState === 'complete') { if (this.isIframeBlank(ifr)) { this.observeIframeLoad(ifr, successFn, errorFn); } else { this.getIframeContents(ifr, successFn, errorFn); } } else { this.observeIframeLoad(ifr, successFn, errorFn); } } catch (e) { // accessing document failed errorFn(e); } } /** * Callback when all iframes are ready for DOM access * @callback DOMIterator~waitForIframesDoneCallback */ /** * Iterates over all iframes and calls the done callback when all of them * are ready for DOM access (including nested ones) * @param {HTMLElement} ctx - The context DOM element * @param {DOMIterator~waitForIframesDoneCallback} done - Done callback */ waitForAllIframes(ctx, doneCb) { let count = 0, iframes = [], array = [], fired = false; // not sure about this timeout; it should guarantee a single done callback, if something went wrong const id = setTimeout(() =&gt; { fired = true; doneCb(); }, this.opt.iframesTimeout); const done = () =&gt; { clearTimeout(id); if ( !fired) { doneCb(); } }; const checkDone = () =&gt; { if (count === iframes.filter(ifr =&gt; !this.hasAttributeValue(ifr, this.attrName, 'error')).length) { done(); } }; const loop = (obj) =&gt; { if ( !obj.iframe || obj.context.location.href !== 'about:blank') { array = []; obj.context.querySelectorAll(obj.iframe ? 'body iframe' : 'iframe').forEach(iframe =&gt; { if ( !DOMIterator.matches(iframe, this.opt.exclude)) { iframes.push(iframe); if ( !iframe.hasAttribute(this.attrName)) { array.push(iframe); } } }); // case when the main context has no iframes or iframes were already handled, e.g. by unmark() method if ( !obj.iframe &amp;&amp; !array.length) { done(); return; } } if (array.length) { array.forEach(iframe =&gt; { this.onIframeReady(iframe, obj =&gt; { count++; loop(obj); }, obj =&gt; { if (this.opt.debug) { console.log(obj.error); } checkDone(); }); }); } else { checkDone(); } }; loop({ context : ctx }); } /** * Creates a NodeIterator on the specified context * @see {@link https://developer.mozilla.org/en/docs/Web/API/NodeIterator} * @param {HTMLElement} ctx - The context DOM element * @param {DOMIterator~whatToShow} whatToShow * @param {DOMIterator~filterCb} filter * @return {NodeIterator} * @access protected */ createIterator(ctx, whatToShow, filter) { return this.opt.window.document.createNodeIterator(ctx, whatToShow, filter, false); } /** * Adds custom style to shadow root when marking, removes when unmark * There is no possibility to check whether a shadow root has any matches though * @param {HTMLElement} node - The shadow root node * @param {HTMLElement} style - The custom style element * @param {boolean} add - A boolean indicating add or remove a style element */ addRemoveStyle(root, style, add) { if (add) { if (style &amp;&amp; root.firstChild &amp;&amp; !root.querySelector('style[data-markjs]')) { const elem = this.opt.window.document.createElement('style'); elem.setAttribute('data-markjs', 'true'); elem.textContent = style; root.insertBefore(elem, root.firstChild); } } else { let elem = root.querySelector('style[data-markjs]'); if (elem) { root.removeChild(elem); } } } /** * Checks whether the node has attribute with the specified name and value * @return {Boolean} */ hasAttributeValue(node, name, value) { return node.hasAttribute(name) &amp;&amp; node.getAttribute(name) === value; } /** * Iterates through all nodes, including shadow DOM nodes, in the specified context * @param {HTMLElement} ctx - The context * @param {DOMIterator~whatToShow} whatToShow * @param {DOMIterator~filterCb} filterCb - Filter callback * @param {DOMIterator~forEachNodeCallback} eachCb - Each callback * @param {DOMIterator~forEachNodeEndCallback} doneCb - End callback * @access protected */ iterateThroughNodes(ctx, whatToShow, filterCb, eachCb, doneCb) { const nodeFilter = this.opt.window.NodeFilter, shadow = this.opt.shadowDOM, iframe = this.opt.iframes; if (iframe || shadow) { const showElement = (whatToShow &amp; nodeFilter.SHOW_ELEMENT) !== 0, showText = (whatToShow &amp; nodeFilter.SHOW_TEXT) !== 0; if (showText) { whatToShow |= nodeFilter.SHOW_ELEMENT; } const traverse = node =&gt; { const iterator = this.createIterator(node, whatToShow); while ((node = iterator.nextNode())) { if (node.nodeType === 1) { // element if (showElement &amp;&amp; filterCb(node)) { eachCb(node); } if (iframe &amp;&amp; node.nodeName.toLowerCase() === 'iframe' &amp;&amp; !DOMIterator.matches(node, this.opt.exclude)) { if (this.hasAttributeValue(node, this.attrName, 'completed')) { this.getIframeContents(node, obj =&gt; { traverse(obj.context); }, () =&gt; {}); } } // there is no possibility to filter a whole shadow DOM, because the 'DOMIterator.matches()' // is not working neither for 'shadowRoot' no for the element itself if (shadow &amp;&amp; node.shadowRoot &amp;&amp; node.shadowRoot.mode === 'open') { this.addRemoveStyle(node.shadowRoot, shadow.style, showText); traverse(node.shadowRoot); } } else if (showText &amp;&amp; node.nodeType === 3 &amp;&amp; filterCb(node)) { // text node eachCb(node); } } }; traverse(ctx); } else { const iterator = this.createIterator(ctx, whatToShow); let node; while ((node = iterator.nextNode())) { if (filterCb(node)) { eachCb(node); } } } doneCb(); } /** * @typedef DOMIterator~whatToShow * @see {@link http://tinyurl.com/zfqqkx2} * @type {number} */ /** * Callback to filter nodes. Can return either true to accept node or false to reject node. * @see {@link http://tinyurl.com/zdczmm2} * @callback DOMIterator~filterCb * @param {Text|HTMLElement} node - The node to filter */ /** * Callback for each node * @callback DOMIterator~forEachNodeCallback * @param {Text|HTMLElement} node - The node node to process */ /** * Callback if all contexts were handled * @callback DOMIterator~forEachNodeEndCallback */ /** * Iterates over all contexts * @param {DOMIterator~whatToShow} whatToShow * @param {DOMIterator~forEachNodeCallback} each - Each callback * @param {DOMIterator~filterCb} filter - Filter callback * @param {DOMIterator~forEachNodeEndCallback} done - End callback * @access public */ forEachNode(whatToShow, each, filter, done = () =&gt; {}) { const contexts = this.getContexts(); let open = contexts.length; if ( !open) { done(); } contexts.forEach(ctx =&gt; { open--; const ready = () =&gt; { this.iterateThroughNodes(ctx, whatToShow, filter, each, () =&gt; { if (open &lt;= 0) { // calls end when all contexts were handled done(); } }); }; if (this.opt.iframes) { this.waitForAllIframes(ctx, ready); } else { ready(); } }); } } export default DOMIterator;",0],
["Elements boundaries∎Note that using a blockElementsBoundary option only makes sense with acrossElements option when highlighting phrases, or RegExp capturing groups, or using a wildcards character * with wildcards : 'withSpaces' option (can match multiple words).∎This, how library aggregates all context(s) text node contents into a single string with blockElementsBoundary: true option: if a block element 'divides' two text nodes, \\x01 character with spaces (it depends) is added between them, e.g. '&lt;h1&gt;Header&lt;/h1&gt;&lt;p&gt;Paragraph&lt;/p&gt;' resulted in 'Header \\x01 Paragraph'.∎With different values the option allows matches across all HTML elements:∎blockElementsBoundary: true except default block elements∎blockElementsBoundary: { tagNames: [..] } except custom element(s)∎blockElementsBoundary: { tagNames: [..], extend : true } except default block elements and custom element(s)∎Boundary object:∎tagNames {string[]} - An array of custom tag names. (default is undefined)∎extend {boolean} - Whether to extend default block elements with custom elements (true) or to make only custom elements have boundaries. (default is false)∎char {string} - A custom boundary char. (default is \\x01)∎Example:∎instance.mark('lorem ipsum dolor', { 'separateWordSearch' : false, 'acrossElements' : true, 'blockElementsBoundary' : true // or 'blockElementsBoundary' : { // only these custom elements have boundaries 'tagNames' : ['div', 'p', 'h1', 'h2'], // optional // custom boundary char, default is '\\x01' 'char' : '.' // optional } });∎Extending default block elements with custom elements:∎instance.markRegExp(/.../gi, { 'acrossElements' : true, 'blockElementsBoundary' : { // custom elements are added to the default block elements 'tagNames' : ['tab-container', 'custom-tag'], 'extend' : true } });∎The default elements are:∎address, area, article, aside, audio, blockquote, body, br, button, canvas, dd, details, div, dl, dt, fieldset, figcaption, figure, footer, form, h1, h2, h3, h4, h5, h6, header, hr, iframe, img, input, label, li, main, map, menu, menuitem, meter, nav, object, ol, output, p, picture, pre, section, select, svg, table, tbody, td, textarea, tfoot, th, thead, tr, track, ul, video",1],
["Filtering matches∎See mark() filter callback and markRegExp() filter callback about filter callback info object properties. To filter RegExp capturing groups see: Filtering capturing groups.∎To filter matches in the mark() method with acrossElements option∎let count = 0; instance.mark('AB', { 'acrossElements' : true, 'filter' : (textNode, term, matchesSoFar, termMatchesSoFar, info) =&gt; { // to mark only the first match info.execution.abort = true; return true; // filter callback requires its own match counter if (info.matchStart) { count++; } // mark the first 10 matches. if (count &gt; 10) { info.execution.abort = true; return false; } // skip between if (count &gt; 10 &amp;&amp; count &lt; 20) { return false; } // mark between if (count &lt;= 10) { return false; } else if (count &gt; 20) { info.execution.abort = true; return false; } return true; } });∎To filter matches in the mark() method without acrossElements option∎let count = 0; instance.mark('AB', { 'filter' : (textNode, term, matchesSoFar, termMatchesSoFar, info) =&gt; { // the only difference is counter implementation count++; } });∎To filter matches in the markRegExp() method∎let count = 0, reg = /.../gi; // if you have access to the RegExp object with 'acrossElements' option, you can // also used `reg.lastIndex = Infinity;` instead of `info.execution.abort = true;` instance.markRegExp(reg, { 'filter' : (textNode, matchString, matchesSoFar, info) =&gt; { // to mark only the first match info.execution.abort = true; return true; // filter callback requires its own match counter if (info.matchStart) { count++; } // mark the first 10 matches. if (count &gt; 10) { info.execution.abort = true; return false; } // skip between if (count &gt; 10 &amp;&amp; count &lt; 20) { return false; } // mark between if (count &lt;= 10) { return false; } else if (count &gt; 20) { info.execution.abort = true; return false; } return true; }, });∎Mark the first desired number of matches on each callback using acrossElements option.∎It's much more limited than the filter callback.∎let reg = /.../gi; instance.markRegExp(reg, { 'acrossElements' : true, 'each' : (markElement, info) =&gt; { // to mark only the first match reg.lastIndex = Infinity; // first 10 matches if (info.count &gt;= 10) { reg.lastIndex = Infinity; } } });",2],
["Getting started∎You can download the package using npm by running:∎$ npm install advanced-mark.js --save-dev∎A dist directory contains files:∎JavaScript∎mark.js∎mark.min.js∎mark.es6.js∎mark.es6.min.js∎jQuery∎jquery.mark.js∎jquery.mark.min.js∎jquery.mark.es6.js∎jquery.mark.es6.min.js∎node.jquery.mark.es6.js for use in Virtual DOMs (contains necessary import $ from 'jquery' declaration)∎TypeScript declaration files∎mark.d.js∎mark.es6.d.js∎jquery.mark.es6.d.js∎node.jquery.mark.es6.d.js∎HTML∎To include library in web page just add:∎&lt;script src=&quot;path/to/mark.js&quot;&gt;&lt;/script&gt;∎Note:the library requires UTF-8 encoding and may needs adding charset attribute:∎&lt;script src=&quot;path/to/mark.min.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;∎API∎There are four API methods:∎mark() - to highlight custom terms∎markRegExp() - to highlight custom regular expressions∎markRanges() - to highlight ranges with a start and length properties (of text or lines with markLines option)∎unmark() - to remove highlights∎JavaScript∎API methods called on an instance object. To initialize a new instance, you have to use:∎var instance = new Mark(context); instance.mark('lorem');∎where context can be:∎a single element get by e.g. document.getElementById() or document.querySelector()∎a NodeList get by e.g. document.querySelectorAll()∎an array containing multiple single elements (Note that internally the array is sorted by the element position in the document)∎a string selector (internally calls document.querySelectorAll())∎jQuery∎API methods called on every jQuery element:∎$(&quot;div.test&quot;).mark('lorem');",3],
["Content∎Getting started∎API∎mark() method∎markRegExp() method∎markRanges() method∎unmark() method∎Usage∎Performance∎Options descriptions∎Filtering matches∎Highlighting separate groups∎Nesting/overlapping ranges and match groups∎Elements boundaries∎Highlighting in shadow DOM∎Highlighting line ranges∎Code examples of using `each` and `done` callbacks∎TypeScript types∎RegExpCreator∎RegExpCreator module∎src∎Mark class∎DOMIterator class∎RegExpCreator class",4],
["Highlighting line ranges∎An option markLines changes the behavior of the markRanges() method. Instead of dealing with text ranges, it is dealt with line ranges. It correctly handles br elements. With an option wrapAllRanges it can highlight nesting/overlapping lines. This option is useful in pre elements. It can be used in other elements, if HTLM page isn't minified or used br elements for formatting.∎You can play with Playground - Examples -&gt; Mark line ranges.∎Note that minimal line number is 1 (a text range can start with 0).∎Highlight and scroll into view the specified code line:∎let elem; const instance = new Mark(document.querySelector('pre')); instance.markRanges([{ start: line, length: 1 }], { 'markLines' : true, 'each' : (markElement, range, info) =&gt; { if (info.matchStart) elem = markElement; markElement.className = 'mark-line'; }, 'done' : () =&gt; { if (elem) elem.scrollIntoView(); } });",5],
["mark() method∎Syntax∎// javascript const instance = new Mark(context); instance.mark(search[, options]); // jQuery $(context).mark(search[, options]);∎Parameters:∎search string or string[] - string or array of strings∎options object - Optional options:∎Option∎Type∎Default∎Description∎element∎string∎mark∎A custom mark element e.g. span.∎className∎string∎''∎A custom class to be added to mark elements.∎exclude∎string or string[]∎[]∎A string or an array of selectors. Specifies DOM elements that should be excluded from searching.∎See exclude option for more details.∎separateWordSearch∎boolean or string∎true∎A boolean value true specifies to break term(s) into separate words and search for each individual word.∎A string value 'preserveTerms' preserved term(s) surrounding by double quotes from breaking into separate words. See separateWordSearch option for more details.∎diacritics∎boolean∎true∎Whether to match diacritic characters∎caseSensitive∎boolean∎false∎Whether to search case sensitive∎accuracy∎string or object∎'partially'∎Either one of the following string value:∎'partially' e.g. searching 'a' mark 'a' in words 'and', 'back', and 'visa'.∎'exactly' This option is actually forced to use an accuracy object, because the default word boundaries are white spaces and start/end of a text node content (with acrossElements option - start/end of a context).∎'startsWith' e.g. searching 'pre' mark the whole words 'prefix', 'predict', and 'prefab'.∎'complementary' e.g. searching 'a' mark the whole words 'and', 'back', and 'visa'.∎The built-in boundaries for values startsWith and complementary are: white spaces and !&quot;#$%&amp;'`()*+,-./:;&lt;=&gt;?@[\\]^_{|}~¡¿ characters.∎Or an object with two properties:∎value: 'exactly' or 'startsWith' or 'complementary'∎limiters: a string or an array of custom word boundary characters, e.g. { value : &quot;exactly&quot;, limiters : &quot;,.;:?!'\\\"()&quot; }∎wildcards∎string∎disabled∎Two characters ? and * used as wildcards unless they are escaped∎disabled: The characters ? and * match itself∎enabled:∎The character ? match any non-white-space character zero or one time.∎The character * match any non-white-space character zero or more times.∎withSpaces:∎The character ? match any character zero or one time.∎The character * match any character zero or more times, but as few times as possible.∎ignoreJoiners∎boolean∎false∎Whether to find matches that contain soft hyphen, zero width space, zero width non-joiner and zero width joiner∎ignorePunctuation∎string or string[]∎[]∎A string or an array of punctuation characters∎synonyms∎object∎{}∎An object with synonyms∎e.g. { 'one': '1' } - '1' is synonym for 'one' and vice versa. The value can be an array, e.g. { 'be': ['am', 'is', 'are'] }.∎acrossElements∎boolean∎false∎Whether to search for matches across elements∎See acrossElements option for more details.∎combinePatterns∎number or boolean∎10∎Combine a specified number of individual term patterns into one∎See Performance for more details.∎cacheTextNodes∎boolean∎undefined∎Caching information to improve performance∎See Performance for more details.∎blockElementsBoundary∎boolean or object∎undefined∎Whether to limit matches within default HTML block elements and/or custom elements∎See Elements boundaries for more details.∎tagNames string[] - An array of custom HTML tag names∎extend boolean - true extends default boundary elements by the custom elements otherwise only the custom elements do have boundaries∎char string - A custom boundary character. The default is \\x01.∎shadowDOM∎boolean∎undefined∎Whether to mark inside shadow DOMs∎See Highlighting in shadow DOM for more details.∎iframes∎boolean∎false∎Whether to mark inside iframes∎iframesTimeout∎number∎5000 ms∎The max time to wait for iframe(s) to load before skipping∎debug∎boolean∎false∎Whether to log messages∎log∎object∎console∎Log messages to a specific object∎filter∎function∎A callback to filter matches. It calls for each match (with acrossElements option, if the match is located across several elements, it calls for each text node which is part of the match) filter : (textNode, term, matchesSoFar, termMatchesSoFar, filterInfo) =&gt; {}∎textNode Text - The text node which includes the match or with acrossElements option can be part of the match∎term string - The current term∎matchesSoFar number - The number of all wrapped matches so far∎termMatchesSoFar number - The number of wrapped matches for the current term so far∎filterInfo object:∎match array - The result of RegExp exec() method∎matchStart boolean - indicate the start of a match AE∎execution object - The helper object for early abort:∎abort boolean - Setting it to true breaks method execution∎offset number - When 'acrossElements: false': the absolute start index of a text node in joined context. When 'acrossElements: true': the sum of the lengths of separated spaces or boundary strings that were added to the composite string so far.∎The function must return either true (to wrap) or false (to skip wrapping mark element). See Filtering matches for more details.∎each∎function∎A callback for each marked element each : (markElement, eachInfo) =&gt; {}∎markElement HTMLElement - The marked DOM element∎eachInfo object:∎match array - The result of RegExp exec() method∎matchStart boolean - Indicate the start of a match AE∎count number - The number of wrapped matches so far∎See Code examples.∎done∎function∎A callback on finish done : (totalMarks, totalMatches, termStats) =&gt; {}∎totalMarks number - The total number of marked elements∎totalMatches number - The total number of matches∎termStats object - An object containing an individual term's matches count∎noMatch∎function∎A callback that is called when a term has no match at all noMatch : (term) =&gt; {}∎term string or string[] - The not found term(s); the parameter is an array when combinePatterns option is used∎Available properties of the filterInfo object depending on options∎options∎match∎matchStart∎execution∎offset∎acrossElements: true∎+∎+∎+∎+∎acrossElements: false∎+∎-∎+∎+∎Available properties of the eachInfo object depending on options∎options∎match∎matchStart∎count∎acrossElements: true∎+∎+∎+∎acrossElements: false∎+∎-∎+∎Example with default options values∎const options = { element : 'mark', className : '', separateWordSearch : true, diacritics : true, exclude : [], caseSensitive : false, accuracy : 'partially', synonyms : {}, ignoreJoiners : false, ignorePunctuation : [], wildcards : 'disabled', acrossElements : false, combinePatterns : false, cacheTextNodes : false, blockElementsBoundary : false, shadowDOM : false, iframes : false, iframesTimeout : 5000, filter : (textNode, term, marksSoFar, termMarksSoFar, filterInfo) =&gt; { return true; // must return either true or false }, each : (markElement, eachInfo) =&gt; {}, done : (totalMarks, totalMatches, termStats) =&gt; {}, noMatch : (term) =&gt; {}, debug : false, log : window.console };∎JavaScript:∎var instance = new Mark(document.querySelector('selector')); instance.mark('test', options);∎jQuery:∎$('selector').mark('test', options);∎AE - only available when acrossElements option is set to true",6],
["Mark class∎import DOMIterator from './domiterator'; import RegExpCreator from './regexpcreator'; /** * Marks search terms in DOM elements * @example * new Mark(document.querySelector('.context')).mark('lorem ipsum'); * @example * new Mark(document.querySelector('.context')).markRegExp(/lorem/gmi); * @example * new Mark('.context').markRanges([{start:10,length:0}]); */ class Mark { /** * @param {HTMLElement|HTMLElement[]|NodeList|string} ctx - The context DOM * element, an array of DOM elements, a NodeList or a selector */ constructor(ctx) { /** * The context of the instance. Either a DOM element, an array of DOM * elements, a NodeList or a selector * @type {HTMLElement|HTMLElement[]|NodeList|string} * @access protected */ this.ctx = ctx; /** * The array of node names which must be excluded from search * @type {array} * @access protected */ this.nodeNames = ['script', 'style', 'title', 'head', 'html']; } /** * @typedef Mark~commonOptions * @type {object.&lt;string&gt;} * @property {object} [window] - A window object * @property {string} [element=&quot;mark&quot;] - HTML element tag name * @property {string} [className] - An optional class name * @property {string[]} [exclude] - An array with exclusion selectors. * Elements matching those selectors will be ignored * @property {boolean} [iframes=false] - Whether to search inside iframes * @property {number} [iframesTimeout=5000] - Maximum ms to wait for a load * event of an iframe * @property {boolean} [acrossElements=false] - Whether to find matches across HTML elements. * By default, only matches within single HTML elements will be found * @property {Mark~markEachCallback} [each] * @property {Mark~markNoMatchCallback} [noMatch] * @property {Mark~commonDoneCallback} [done] * @property {boolean} [debug=false] - Whether to log messages * @property {object} [log=window.console] - Where to log messages (only if debug is true) */ /** * Options defined by the user. They will be initialized from one of the * public methods. See {@link Mark#mark}, {@link Mark#markRegExp}, * {@link Mark#markRanges} and {@link Mark#unmark} for option properties. * @type {object} * @param {object} [val] - An object that will be merged with defaults * @access protected */ set opt(val) { if ( !(val &amp;&amp; val.window &amp;&amp; val.window.document) &amp;&amp; typeof window === 'undefined') { throw new Error('Mark.js: please provide a window object as an option.'); } const win = val &amp;&amp; val.window || window; this._opt = Object.assign({}, { 'window': win, 'element': '', 'className': '', 'exclude': [], 'iframes': false, 'iframesTimeout': 5000, 'separateWordSearch': true, 'acrossElements': false, 'ignoreGroups': 0, 'each': () =&gt; {}, 'noMatch': () =&gt; {}, 'filter': () =&gt; true, 'done': () =&gt; {}, 'debug': false, 'log': win.console }, val); if ( !this._opt.element) { this._opt.element = 'mark'; } // shortens a lengthy name this.filter = win.NodeFilter; // this empty text node used to simplify code this.empty = win.document.createTextNode(''); } get opt() { return this._opt; } /** * An instance of DOMIterator * @type {DOMIterator} * @access protected */ get iterator() { // always return new instance in case there were option changes return new DOMIterator(this.ctx, this.opt); } /** * Logs a message if log is enabled * @param {string} msg - The message to log * @param {string} [level=&quot;debug&quot;] - The log level, e.g. &lt;code&gt;warn&lt;/code&gt; * &lt;code&gt;error&lt;/code&gt;, &lt;code&gt;debug&lt;/code&gt; * @access protected */ log(msg, level = 'debug') { if (this.opt.debug) { const log = this.opt.log; if (typeof log === 'object' &amp;&amp; typeof log[level] === 'function') { log[level](`mark.js: ${msg}`); } } } /** * @typedef Mark~logObject * @type {object} * @property {string} message - The message * @property {object} obj - The object */ /** * Logs errors and info * @param {array} array - The array of objects */ report(array) { array.forEach(item =&gt; { this.log(`${item.text} ${JSON.stringify(item.obj)}`, item.level || 'debug'); if ( !item.skip) { this.opt.noMatch(item.obj); } }); } /** * Checks the validity of cache objects (mark instance can calls several methods with different setting * of the cacheTextNodes option, which breaks the relation of the DOM nodes and cache object nodes) * @param {object} [opt] - Optional options object * @return {object} */ checkOption(opt, del) { this.opt = opt; let dict = this.cacheDict, clear = true; if (dict) { // It allows using cache object if the type and cacheTextNodes option doesn't change if ( !del &amp;&amp; this.opt.cacheTextNodes) { if (this.opt.acrossElements) { if (dict.across) { clear = false; } } else if ( !dict.across) { clear = false; } } if (clear) { this.cacheDict = null; } } } /** * Splits string into separate words if 'separateWordSearch' option has value 'true' but, * if it has string value 'preserveTerms', prevents splitting terms surrounding by double quotes. * Removes duplicate or empty entries and sort by the length in descending order. * It also initializes termStats object. * @param {string|string[]} sv - Search value, either a string or an array of strings * @return {object} * @access protected */ getSeachTerms(sv) { const search = typeof sv === 'string' ? [sv] : sv, separate = this.opt.separateWordSearch, array = [], termStats = {}, split = str =&gt; { str.split(/ +/).forEach(word =&gt; add(word)); }, add = str =&gt; { if (str.trim() &amp;&amp; array.indexOf(str) === -1) { array.push(str); // initializes term property termStats[str] = 0; } }; search.forEach(str =&gt; { if (separate) { if (separate === 'preserveTerms') { // allows highlight quoted terms no matter how many quotes it contains on each side, // e.g. ' &quot;&quot;term&quot;&quot; ' or ' &quot;&quot;&quot;&quot;term&quot; ' str.split(/&quot;(&quot;*[^&quot;]+&quot;*)&quot;/).forEach((term, i) =&gt; { if (i % 2 &gt; 0) add(term); else split(term); }); } else { split(str); } } else { add(str); } }); array.sort((a, b) =&gt; b.length - a.length); return { terms : array, termStats }; } /** * Check if a value is a number * @param {number|string} value - the value to check; * numeric strings allowed * @return {boolean} * @access protected */ isNumeric(value) { // http://stackoverflow.com/a/16655847/145346 // eslint-disable-next-line eqeqeq return Number(parseFloat(value)) == value; } /** * Filters valid ranges, sorts and, if wrapAllRanges option is false, filters out nesting/overlapping ranges * @param {Mark~setOfRanges} array - unprocessed raw array * @param {Mark~logObject} logs - The array of logs objects * @return {Mark~setOfRanges} - processed array with any invalid entries removed * @access protected */ checkRanges(array, logs, min, max) { // a range object must have the start and length properties with numeric values // [{start: 0, length: 5}, ..] const level = 'error'; // filters and sorts valid ranges const ranges = array.filter(range =&gt; { if (this.isNumeric(range.start) &amp;&amp; this.isNumeric(range.length)) { range.start = parseInt(range.start); range.length = parseInt(range.length); if (range.start &gt;= min &amp;&amp; range.start &lt; max &amp;&amp; range.length &gt; 0) { return true; } } logs.push({ text : 'Invalid range: ', obj : range, level }); return false; }).sort((a, b) =&gt; a.start - b.start); if (this.opt.wrapAllRanges) { return ranges; } let lastIndex = 0, index; // filters out nesting/overlapping ranges return ranges.filter(range =&gt; { index = range.start + range.length; if (range.start &gt;= lastIndex) { lastIndex = index; return true; } logs.push({ text : (index &lt; lastIndex ? 'Nest' : 'Overlapp') + 'ing range: ', obj : range, level }); return false; }); } /** * @typedef Mark~blockElementsBoundaryObject * @type {object} * @property {array} [tagNames] - The array of custom tag names * @property {boolean} [extend] - Whether to extend the default boundary elements with custom elements * or set only custom elements to boundary type * @property {string} [char] - The custom separating char */ /** * Sets type: 1 - separate by space, 2 - separate by boundary char with space(s) * @param {object} tags - The object containing HTML element tag names */ setType(tags, boundary) { const custom = Array.isArray(boundary.tagNames) &amp;&amp; boundary.tagNames.length; if (custom) { // normalizes custom elements names and adds to the tags object with boundary type value boundary.tagNames.forEach(name =&gt; tags[name.toLowerCase()] = 2); } // if not extend, the only custom tag names are set to a boundary type if ( !custom || boundary.extend) { // sets all tags value to the boundary for (const key in tags) { tags[key] = 2; } } tags['br'] = 3; } /** * @typedef Mark~nodeInfoAcross * @property {Text} node - The DOM text node * @property {number} start - The start index within the composite string * @property {number} end - The end index within the composite string * @property {number} offset - The offset is used to correct position if space or string * was added to end of composite string after this node textContent * @property {number} startOffset - The sum of all offsets that were added * to the composite string before this node. It has a negative value. */ /** * @typedef Mark~getTextNodesAcrossDict * @type {object.&lt;string&gt;} * @property {string} text - The composite string of all text nodes * @property {Mark~nodeInfoAcross[]} nodes - An array of node info objects * @property {number} lastIndex - The property used to store the nodes last index * @property {number} lastTextIndex - The property used to store the composite string last index */ /** * Callback * @callback Mark~getTextNodesAcrossCallback * @param {Mark~getTextNodesAcrossDict} */ /** * Calls the callback with an object containing all text nodes (including iframe text nodes) * with start and end positions and the composite value of them (string) * @param {Mark~getTextNodesAcrossCallback} cb - Callback * @access protected */ getTextNodesAcross(cb) { // uses cache dict if it's already built if (this.opt.cacheTextNodes &amp;&amp; this.cacheDict) { // it's only requires reset two indexes this.cacheDict.lastIndex = 0; this.cacheDict.lastTextIndex = 0; cb(this.cacheDict); return; } // a space or string can be safely added to the end of a text node when two text nodes // are 'separated' by element with one of these names const tags = { div : 1, p : 1, li : 1, td : 1, tr : 1, th : 1, ul : 1, ol : 1, dd : 1, dl : 1, dt : 1, h1 : 1, h2 : 1, h3 : 1, h4 : 1, h5 : 1, h6 : 1, hr : 1, blockquote : 1, figcaption : 1, figure : 1, pre : 1, table : 1, thead : 1, tbody : 1, tfoot : 1, input : 1, img : 1, nav : 1, details : 1, label : 1, form : 1, select : 1, menu : 1, br : 3, menuitem : 1, main : 1, section : 1, article : 1, aside : 1, picture : 1, output : 1, button : 1, header : 1, footer : 1, address : 1, area : 1, canvas : 1, map : 1, fieldset : 1, textarea : 1, track : 1, video : 1, audio : 1, body : 1, iframe : 1, meter : 1, object : 1, svg : 1 }; const nodes = [], boundary = this.opt.blockElementsBoundary, priorityType = boundary ? 2 : 1; let ch = '\\x01', tempType, type, prevNode; if (boundary) { this.setType(tags, boundary); if (boundary.char) { ch = boundary.char.charAt(0); } } const obj = { text : '', regex : /\\s/, tags : tags, boundary : boundary, startOffset : 0, str : '', ch : ch }; this.iterator.forEachNode(this.filter.SHOW_ELEMENT | this.filter.SHOW_TEXT, node =&gt; { // each if (prevNode) { nodes.push(this.getNodeInfo(prevNode, node, type, obj)); } type = null; prevNode = node; }, node =&gt; { // filter if (node.nodeType === 1) { // element tempType = tags[node.nodeName.toLowerCase()]; if (tempType === 3) { // br element obj.str += '\\n'; } if ( !type || tempType === priorityType) { type = tempType; } return false; } return !this.excluded(node.parentNode); }, () =&gt; { // done // processes the last node if (prevNode) { nodes.push(this.getNodeInfo(prevNode, null, type, obj)); } cb(this.createDict(obj.text, nodes, true)); }); } /** * Creates object * @param {Text} prevNode - The previous DOM text node * @param {Text} node - The current DOM text node * @param {number|null} type - define how to separate the previous and current text nodes textContent; * type is null when nodes doesn't separated by block elements * @param {object} obj - The auxiliary object to pass multiple parameters to the method */ getNodeInfo(prevNode, node, type, obj) { const start = obj.text.length, startOffset = obj.startOffset, ch = obj.ch; let offset = 0, str = obj.str, text = prevNode.textContent; if (node) { const startBySpace = obj.regex.test(node.textContent[0]), both = startBySpace &amp;&amp; obj.regex.test(text[text.length - 1]); if (obj.boundary || !both) { let separate = type; // searches for the first parent of the previous text node that met condition // and checks does they have the same parent or the parent contains the current text node if (!type) { let parent = prevNode.parentNode; while (parent) { type = obj.tags[parent.nodeName.toLowerCase()]; if (type) { separate = !(parent === node.parentNode || parent.contains(node)); break; } parent = parent.parentNode; } } if (separate) { if ( !both) { str += type === 1 ? ' ' : type === 2 ? ' ' + ch + ' ' : ''; } else if (type === 2) { str += both ? ch : startBySpace ? ' ' + ch : ch + ' '; } } } } if (str) { text += str; offset = str.length; obj.startOffset -= offset; obj.str = ''; } obj.text += text; return this.createInfo(prevNode, start, obj.text.length - offset, offset, startOffset); } /** * @typedef Mark~nodeInfo * @property {Text} node - The DOM text node * @property {number} start - The start index within the composite string * @property {number} end - The end index within the composite string * @property {number} offset - This property is required for compatibility with [Mark~nodeInfoAcross] * for {@link Mark#markRanges} */ /** * @typedef Mark~getTextNodesDict * @type {object.&lt;string&gt;} * @property {string} text - The composite value of all text nodes * @property {Mark~nodeInfo[]} nodes - The array of objects * @property {number} lastIndex - The property used to store the nodes the last index * @property {number} lastTextIndex - This property is required for compatibility with [Mark~getTextNodesAcrossDict] * for {@link Mark#markRanges} */ /** * Callback * @callback Mark~getTextNodesCallback * @param {Mark~getTextNodesDict} */ /** * Calls the callback with an object containing all text nodes (including iframe text nodes) * with start and end positions and the composite value of them (string) * @param {Mark~getTextNodesCallback} cb - Callback * @access protected */ getTextNodes(cb) { // uses cache cacheDict if it's already built if (this.opt.cacheTextNodes &amp;&amp; this.cacheDict) { cb(this.cacheDict); return; } const nodes = [], regex = /\\n/g, newLines = [0], lines = this.opt.markLines, show = this.filter.SHOW_TEXT | (lines ? this.filter.SHOW_ELEMENT : 0); let text = '', len = 0, rm; this.iterator.forEachNode(show, node =&gt; { // each if (lines) { while ((rm = regex.exec(node.textContent)) !== null) { newLines.push(len + rm.index); } } text += node.textContent; nodes.push({ start : len, end : (len = text.length), offset : 0, node : node }); }, node =&gt; { // filter if (lines &amp;&amp; node.nodeType === 1) { if (node.tagName.toLowerCase() === 'br') { newLines.push(len); } return false; } return !this.excluded(node.parentNode); }, () =&gt; { // done const dict = this.createDict(text, nodes, false); if (lines) { newLines.push(len); dict.newLines = newLines; } cb(dict); }); } /** * Creates dict object * @param {string} text - The composite string * @param {Mark~nodeInfo[]|Mark~nodeInfoAcross[]} nodes - The array of info objects * @param {boolean} across - Indicate that cache dict type */ createDict(text, nodes, across) { const dict = { text : text, nodes: nodes, lastIndex: 0, lastTextIndex: 0 }; if (this.opt.cacheTextNodes) { this.cacheDict = dict; this.cacheDict.across = across; } return dict; } /** * Checks if an element matches any of the specified exclude selectors. * @param {HTMLElement} elem - The element to check * @return {boolean} * @access protected */ excluded(elem) { // it's faster to check if an array contains the node name than a selector in 'DOMIterator.matches()' // also it allows using a string of selectors instead of an array with the 'exclude' option return this.nodeNames.indexOf(elem.nodeName.toLowerCase()) !== -1 || DOMIterator.matches(elem, this.opt.exclude); } /** * Splits the text node into two or three nodes and wraps the necessary node or wraps the input node * Creates info object(s) related to the newly created node(s) and inserts into dict.nodes or replace an existing one * It doesn't create empty sibling text nodes when `Text.splitText()` method splits a text node at the start/end * @param {Mark~wrapRangeInsertDict} dict - The dictionary * @param {object} n - The currently processed info object * @param {number} s - The position where to start wrapping * @param {number} e - The position where to end wrapping * @param {number} start - The start position of the match * @param {number} index - The current index of the processed object * @return {object} Returns object containing the mark element, the splitted text node * that will appear after the wrapped text node, and increment number */ wrapRangeInsert(dict, n, s, e, start, index) { const ended = e === n.node.textContent.length, end = n.end; // type: 0 - whole text node, 1 - from the start, 2 - to the end, 3 - between let type = 1, splitIndex = e, node = n.node; // prevents creating empty sibling text nodes at the start/end of a text node if (s !== 0) { node = node.splitText(s); splitIndex = e - s; type = ended ? 2 : 3; } else if (ended) { // whole type = 0; } const retNode = ended ? this.empty : node.splitText(splitIndex), mark = this.wrapTextNode(node), markChild = mark.childNodes[0], nodeInfo = this.createInfo(retNode, type === 0 || type === 2 ? end : n.start + e, end, n.offset, n.startOffset); if (type === 0) { n.node = markChild; return { mark, nodeInfo, increment : 0 }; } const info = this.createInfo(markChild, type === 1 ? n.start : start, n.start + e, 0, n.startOffset); // inserts new node(s) info in dict.nodes depending where a range is located in a text node if (type === 1) { dict.nodes.splice(index, 1, info, nodeInfo); } else { if (type === 2) { dict.nodes.splice(index + 1, 0, info); } else { dict.nodes.splice(index + 1, 0, info, nodeInfo); } n.end = start; n.offset = 0; } return { mark, nodeInfo, increment : type &lt; 3 ? 1 : 2 }; } /** * Creates object * @param {Text} node - The DOM text node * @param {number} start - The position where to start wrapping * @param {number} end - The position where to end wrapping * @param {number} offset - The length of space/string that is added to end of composite string * after this node textContent * @param {number} startOffset - The sum of all offsets that were added before this node */ createInfo(node, start, end, offset, startOffset) { return { node, start, end, offset, startOffset }; } /** * Splits the text node into two or three nodes and wraps the necessary node or wraps the input node * It doesn't create empty sibling text nodes when `Text.splitText()` method splits a text node at the start/end * @param {Text} node - The DOM text node * @param {number} start - The position where to start wrapping * @param {number} end - The position where to end wrapping * @param {Mark~wrapRangeEachCallback} eachCb - Each callback * @return {Text} * @access protected */ wrapRange(node, start, end, eachCb) { let ended = end === node.textContent.length, index = end, retNode; if (start !== 0) { node = node.splitText(start); index = end - start; } retNode = ended ? this.empty : node.splitText(index); eachCb(this.wrapTextNode(node)); return retNode; } /** * Wraps the new element with the necessary attributes around text node * @param {Text} node - The DOM text node * @return {HTMLElement} Returns the created DOM node */ wrapTextNode(node) { let markNode = this.opt.window.document.createElement(this.opt.element); markNode.setAttribute('data-markjs', 'true'); if (this.opt.className) { markNode.setAttribute('class', this.opt.className); } markNode.textContent = node.textContent; node.parentNode.replaceChild(markNode, node); return markNode; } /** * @typedef Mark~wrapRangeAcrossDict * @type {object.&lt;string&gt;} * @property {string} text - The composite string of all text nodes * @property {Mark~nodeInfoAcross[]} nodes - An array of node info objects * @property {number} lastIndex - The property used to store the nodes last index * @property {number} lastTextIndex - The property used to store the string last index */ /** * Each callback * @callback Mark~wrapRangeAcrossEachCallback * @param {HTMLElement} node - The wrapped DOM element * @param {boolean} rangeStart - Indicate the start of the current range */ /** * Filter callback * @callback Mark~wrapRangeAcrossFilterCallback * @param {object} n - The current node info object of the dict.nodes */ /** * Determines matches by start and end positions using the text node dictionary * and calls {@link Mark#wrapRange} or {@link Mark#wrapRangeInsert} to wrap them * @param {Mark~wrapRangeAcrossDict} dict - The dictionary * @param {number} start - The start index of the match * @param {number} end - The end index of the match * @param {Mark~wrapRangeAcrossFilterCallback} filterCb - Filter callback * @param {Mark~wrapRangeAcrossEachCallback} eachCb - Each callback * @access protected */ wrapRangeAcross(dict, start, end, filterCb, eachCb) { // dict.lastIndex stores the last node index to avoid iteration from the beginning let i = dict.lastIndex, rangeStart = true; // 'cacheTextNodes' option must enable 'wrapAllRanges' code here const wrapAllRanges = this.opt.wrapAllRanges || this.opt.cacheTextNodes; if (wrapAllRanges) { // finds the starting index in case of nesting/overlapping while (i &gt; 0 &amp;&amp; dict.nodes[i].start &gt; start) { i--; } } else if (start &lt; dict.lastTextIndex) { // case of overlapping match; can occurs with separateGroups option and capturing group inside assertion return; } for (i; i &lt; dict.nodes.length; i++) { if (i + 1 === dict.nodes.length || dict.nodes[i+1].start &gt; start) { let n = dict.nodes[i]; if ( !filterCb(n)) break; // map range from dict.text to text node const s = start - n.start, e = (end &gt; n.end ? n.end : end) - n.start; // prevents exception if something went wrong, useful for debugging purpose if (s &gt;= 0 &amp;&amp; e &gt; s) { if (wrapAllRanges) { const obj = this.wrapRangeInsert(dict, n, s, e, start, i); n = obj.nodeInfo; eachCb(obj.mark, rangeStart); } else { n.node = this.wrapRange(n.node, s, e, node =&gt; { eachCb(node, rangeStart); }); // sets the new text node start index in the case of subsequent matches in the same text node n.start += e; // sets the last text index dict.lastTextIndex = n.start; } rangeStart = false; } if (end &gt; n.end) { // the range extends to the next text node start = n.end + n.offset; } else { break; } } } // sets the last index dict.lastIndex = i; } /** * @typedef Mark~paramsObject * @type {object} * @property {RegExp} regex - The regular expression to be searched for * @property {array} groups - The array containing main groups indexes */ /** * Filter callback before each wrapping * @callback Mark~wrapGroupsFilterCallback * @param {string} group - The current group matching string * @param {Text} node - The text node where the match occurs * @param {number} index - The current group index */ /** * Callback for each wrapped element * @callback Mark~wrapGroupsEachCallback * @param {HTMLElement} element - The marked DOM element * @param {number} index - The current group index */ /** * Wraps match groups * @param {Text} node - The text node where the match occurs * @param {array} match - The result of RegExp exec() method * @param {Mark~paramsObject} params - The object containing two properties * @param {Mark~wrapGroupsFilterCallback} filterCb - Filter callback * @param {Mark~wrapGroupsEachCallback} eachCb - Each callback */ wrapGroups(node, match, params, filterCb, eachCb) { let startIndex = match.index, isWrapped = false, group, start; // the only way to avoid nested group being searched by the indexOf method // is to parse the RegExp pattern and collect main groups indexes params.groups.forEach(index =&gt; { group = match[index]; if (group) { start = node.textContent.indexOf(group, startIndex); if (start !== -1) { if (filterCb(node, group, index)) { node = this.wrapRange(node, start, start + group.length, node =&gt; { eachCb(node, index); }); // resets the startIndex to start searching the beginning of new text node startIndex = 0; isWrapped = true; } else { // group is filtered out, so start next search from the group end startIndex = start + group.length; } } } }); // resets the lastIndex only when any of group is wrapped (to avoid infinite loop) if (isWrapped) { params.regex.lastIndex = 0; } return node; } /** * Filter callback before each wrapping * @callback Mark~wrapGroupsAcrossFilterCallback * @param {string} group - The current group matching string * @param {Text} node - The text node where the match occurs or is part of the match * @param {number} index - The current group index */ /** * Callback for each wrapped element * @callback Mark~wrapGroupsAcrossEachCallback * @param {HTMLElement} element - The marked DOM element * @param {boolean} groupStart - Indicate the start of a group * @param {number} index - The current group index */ /** * Wraps match groups across elements * @param {Mark~wrapGroupsAcrossDict} dict - The dictionary * @param {array} match - The result of RegExp exec() method * @param {Mark~paramsObject} params - The object containing two properties * @param {Mark~wrapGroupsAcrossFilterCallback} filterCb - Filter callback * @param {Mark~wrapGroupsAcrossEachCallback} eachCb - Each callback */ wrapGroupsAcross(dict, match, params, filterCb, eachCb) { let startIndex = 0, group, start, end; const s = match.index, text = match[0], wrap = (start, end, index) =&gt; { this.wrapRangeAcross(dict, s + start, s + end, obj =&gt; { return filterCb(obj, text, index); }, (node, groupStart) =&gt; { eachCb(node, groupStart, index); }); }; //a way to mark nesting groups, it first wraps the whole match as a group 0 if (this.opt.wrapAllRanges) { wrap(0, text.length, 0); } // the only way to avoid nested group being searched by the indexOf method // is to parse the RegExp pattern and collect main groups indexes params.groups.forEach(index =&gt; { group = match[index]; if (group) { // this approach only reliable with adjacent groups; unwanted group(s) can be easily filtered out start = text.indexOf(group, startIndex); if (start !== -1) { end = start + group.length; wrap(start, end, index); startIndex = end; } } }); } /** * Filter callback before each wrapping * @callback Mark~wrapGroupsDFlagFilterCallback * @param {Text} node - The text node where the match occurs * @param {string} group - The current group matching string * @param {number} i - The current group index */ /** * Callback for each wrapped element * @callback Mark~wrapGroupsDFlagEachCallback * @param {HTMLElement} element - The marked DOM element * @param {number} i - The current group index */ /** * Wraps match groups with RegExp.hasIndices * @param {Text} node - The text node where the match occurs * @param {array} match - The result of RegExp exec() method * @param {Mark~paramsObject} params - The object containing one property * @param {Mark~wrapGroupsDFlagCallback} filterCb - Filter callback * @param {Mark~wrapGroupsDFlagEachCallback} eachCb - Each callback */ wrapGroupsDFlag(node, match, params, filterCb, eachCb) { let lastIndex = 0, offset = 0, i = 0, isWrapped = false, group, start, end = 0; while (++i &lt; match.length) { group = match[i]; if (group) { start = match.indices[i][0]; //it prevents marking nested group - parent group is already marked if (start &gt;= lastIndex) { end = match.indices[i][1]; if (filterCb(node, group, i)) { // when a group is wrapping, a text node is split at the end index, // so to correct the start &amp; end indexes of a new text node, subtract // the end index of the last wrapped group (offset) node = this.wrapRange(node, start - offset, end - offset, node =&gt; { eachCb(node, i); }); if (end &gt; lastIndex) { lastIndex = end; } offset = end; isWrapped = true; } } } } // resets the lastIndex when at least one group is wrapped (prevents infinite loop) if (isWrapped) { params.regex.lastIndex = 0; // when the match has zero length, we need to control the RegExp lastIndex } else if (match[0].length === 0) { this.setLastIndex(params.regex, end); } return node; } /** * Filter callback before each wrapping * @callback Mark~wrapGroupsDFlagAcrossFilterCallback * @param {Text} node - The text node where the match occurs or is part of the match * @param {string} group - The current group matching string * @param {number} i - The current group index */ /** * Callback for each wrapped element * @callback Mark~wrapGroupsDFlagAcrossEachCallback * @param {HTMLElement} element - The marked DOM element * @param {boolean} groupStart - Indicate the start of a group * @param {number} i - The current group index */ /** * Wraps match groups with RegExp.hasIndices across elements * @param {Mark~wrapGroupsDFlagAcrossDict} dict - The dictionary * @param {array} match - The result of RegExp exec() method * @param {Mark~paramsObject} params - The empty object * @param {Mark~wrapGroupsDFlagAcrossFilterCallback} filterCb - Filter callback * @param {Mark~wrapGroupsDFlagAcrossEachCallback} eachCb - Each callback */ wrapGroupsDFlagAcross(dict, match, params, filterCb, eachCb) { let lastIndex = 0, i = 0, group, start, end = 0, isWrapped; while (++i &lt; match.length) { group = match[i]; if (group) { start = match.indices[i][0]; // the wrapAllRanges option allows wrapping nested group(s), // the 'start &gt;= lastIndex' prevents wrapping nested group(s) - the parent group is already wrapped if (this.opt.wrapAllRanges || start &gt;= lastIndex) { end = match.indices[i][1]; isWrapped = false; this.wrapRangeAcross(dict, start, end, obj =&gt; { return filterCb(obj, group, i); }, (node, groupStart) =&gt; { isWrapped = true; eachCb(node, groupStart, i); }); // group may be filtered out if (isWrapped &amp;&amp; end &gt; lastIndex) { lastIndex = end; } } } } // when the match has zero length, we need to control the RegExp lastIndex if (match[0].length === 0) { this.setLastIndex(params.regex, end); } } /** * When processing zero length match, there is a need to set the RegExp lastIndex depending on conditions. * It's necessary to avoid infinite loop and set position from which to start the next match * @param {RegExp} regex - The regular expression to be searched for * @param {number} end - The end index of the last processed group */ setLastIndex(regex, end) { const index = regex.lastIndex; // end &gt; index - case when a capturing group is inside positive lookahead assertion // end &gt; 0 - case when a match is filtered out or a capturing group is inside positive lookbehind assertion regex.lastIndex = end &gt; index ? end : end &gt; 0 ? index + 1 : Infinity; } /** * Parses the RegExp pattern and collects main groups (children of the group[0]) indexes * @param {RegExp} regex - The regular expression to be searched for * @return {array} groups - The array containing main groups indexes */ collectGroupIndexes(regex) { let groups = [], stack = [], index = 0, brackets = 0, str = regex.source, rm, // any escaped char | charSet | start of a capturing groups '(?&lt;, (' | rest open parentheses | close parenthesis reg = /(?:\\\\.)+|\\[(?:[^\\\\\\]]|(?:\\\\.))+\\]|(\\(\\?&lt;(?![=!])|\\((?!\\?))|(\\()|(\\))/g; while ((rm = reg.exec(str)) !== null) { if (rm[1]) { // the start of a capturing group stack.push(1); index++; if (brackets++ === 0) { groups.push(index); } } else if (rm[2]) { // an open parenthesis stack.push(0); } else if (rm[3] &amp;&amp; stack.pop()) { // a close parenthesis brackets--; } } return groups; } /** * @typedef Mark~filterInfoObject * @type {object} * @property {array} match - The result of RegExp exec() method * @property {boolean} matchStart - Indicate the start of match. It's only available * with the 'acrossElements' option * @property {number} groupIndex - The group index. It's only available * with 'separateGroups' option * @property {object} execution - The helper object for early abort. Contains * boolean 'abort' property. * @property {number} offset - With the 'acrossElements' option: the length * of spaces/strings that were added to the composite string so far. * Without this option: the absolute start index of a text node in joined contexts. * It is necessary to translate the local node indexes to the absolute ones. */ /** * @typedef Mark~eachInfoObject * @type {object} * @property {array} match - The result of RegExp exec() method * @property {boolean} matchStart - Indicate the start of match. It's only available * with the 'acrossElements' option * @property {number} count - The current number of matches * @property {number} groupIndex - The index of current match group. It's only * available with 'separateGroups' option * @property {boolean} groupStart - Indicate the start of group. It's only * available with both 'acrossElements' and 'separateGroups' options */ /** * Group filter callback before each wrapping * @callback Mark~wrapSeparateGroupsFilterCallback * @param {Text} node - The text node where the match occurs * @param {string} group - The matching string of the current group * @param {Mark~filterInfoObject} info - The object containing the match information */ /** * Callback for each wrapped element * @callback Mark~wrapSeparateGroupsEachCallback * @param {HTMLElement} element - The marked DOM element * @param {Mark~eachInfoObject} - The object containing the match information */ /** * Callback on end * @callback Mark~wrapSeparateGroupsEndCallback * @param {number} count - The number of matches */ /** * Wraps match capturing groups * @param {RegExp} regex - The regular expression to be searched for * @param {number} unused * @param {Mark~wrapSeparateGroupsFilterCallback} filterCb - Filter callback * @param {Mark~wrapSeparateGroupsEachCallback} eachCb - Each callback * @param {Mark~wrapSeparateGroupsEndCallback} endCb * @access protected */ wrapSeparateGroups(regex, unused, filterCb, eachCb, endCb) { const hasIndices = regex.hasIndices, fn = hasIndices ? 'wrapGroupsDFlag' : 'wrapGroups', params = { regex : regex, groups : hasIndices ? {} : this.collectGroupIndexes(regex) }, execution = { abort : false }, info = { execution : execution }; let node, match, filterStart, eachStart, count = 0; this.getTextNodes(dict =&gt; { dict.nodes.every(obj =&gt; { node = obj.node; info.offset = obj.start; while ((match = regex.exec(node.textContent)) !== null &amp;&amp; (hasIndices || match[0] !== '')) { info.match = match; filterStart = eachStart = true; node = this[fn](node, match, params, (node, group, grIndex) =&gt; { // filter info.matchStart = filterStart; info.groupIndex = grIndex; filterStart = false; return filterCb(node, group, info); }, (node, grIndex) =&gt; { // each if (eachStart) { count++; } eachCb(node, { match : match, matchStart : eachStart, count : count, groupIndex : grIndex, }); eachStart = false; }); if (execution.abort) break; } // breaks loop on custom abort return !execution.abort; }); endCb(count); }); } /** * Filter callback before each wrapping * @callback Mark~wrapSeparateGroupsAcrossFilterCallback * @param {Text} node - The text node where the match occurs or is part of the match * @param {string} group - The matching string of the current group * @param {Mark~filterInfoObject} info - The object containing the match information */ /** * Callback for each wrapped element * @callback Mark~wrapSeparateGroupsAcrossEachCallback * @param {HTMLElement} node - The marked DOM element * @param {Mark~eachInfoObject} - The object containing the match information */ /** * Callback on end * @callback Mark~wrapSeparateGroupsAcrossEndCallback * @param {number} count - The number of all matches */ /** * Wraps match capturing groups across elements * @param {RegExp} regex - The regular expression to be searched for * @param {number} unused * @param {Mark~wrapSeparateGroupsAcrossFilterCallback} filterCb - Filter callback * @param {Mark~wrapSeparateGroupsAcrossEachCallback} eachCb - Each callback * @param {Mark~wrapSeparateGroupsAcrossEndCallback} endCb * @access protected */ wrapSeparateGroupsAcross(regex, unused, filterCb, eachCb, endCb) { const hasIndices = regex.hasIndices, fn = hasIndices ? 'wrapGroupsDFlagAcross' : 'wrapGroupsAcross', params = { regex : regex, groups : hasIndices ? {} : this.collectGroupIndexes(regex) }, execution = { abort : false }, info = { execution : execution }; let match, filterStart, eachStart, count = 0; this.getTextNodesAcross(dict =&gt; { while ((match = regex.exec(dict.text)) !== null &amp;&amp; (hasIndices || match[0] !== '')) { info.match = match; filterStart = eachStart = true; this[fn](dict, match, params, (obj, group, grIndex) =&gt; { // filter info.matchStart = filterStart; info.groupIndex = grIndex; info.offset = obj.startOffset; filterStart = false; return filterCb(obj.node, group, info); }, (node, groupStart, grIndex) =&gt; { // each if (eachStart) { count++; } eachCb(node, { match : match, matchStart : eachStart, count : count, groupIndex : grIndex, groupStart : groupStart, }); eachStart = false; }); if (execution.abort) break; } endCb(count); }); } /** * Filter callback before each wrapping * @callback Mark~wrapMatchesFilterCallback * @param {Text} node - The text node where the match occurs * @param {string} str - The matching string * @param {Mark~filterInfoObject} filterInfo - The object containing the match information */ /** * Callback for each wrapped element * @callback Mark~wrapMatchesEachCallback * @param {HTMLElement} element - The marked DOM element * @param {Mark~eachInfoObject} eachInfo - The object containing the match information */ /** * Callback on end * @callback Mark~wrapMatchesEndCallback * @param {number} count - The number of all matches */ /** * Wraps the instance element and class around matches within single HTML elements in all contexts * @param {RegExp} regex - The regular expression to be searched for * @param {number} ignoreGroups - A number of RegExp capturing groups to ignore from the beginning of a match * @param {Mark~wrapMatchesFilterCallback} filterCb - Filter callback * @param {Mark~wrapMatchesEachCallback} eachCb - Each callback * @param {Mark~wrapMatchesEndCallback} endCb * @access protected */ wrapMatches(regex, ignoreGroups, filterCb, eachCb, endCb) { const index = ignoreGroups === 0 ? 0 : ignoreGroups + 1, execution = { abort : false }, filterInfo = { execution : execution }; let info, node, match, str, count = 0; this.getTextNodes(dict =&gt; { for (let k = 0; k &lt; dict.nodes.length; k++) { info = dict.nodes[k]; node = info.node; while ((match = regex.exec(node.textContent)) !== null &amp;&amp; (str = match[index]) !== '') { filterInfo.match = match; filterInfo.offset = info.start; if ( !filterCb(node, str, filterInfo)) { continue; } // calculates the start index inside node.textContent let i = 0, start = match.index; while (++i &lt; index) { if (match[i]) { // allows any ignore group to be undefined start += match[i].length; } } const end = start + str.length; if (this.opt.cacheTextNodes) { const obj = this.wrapRangeInsert(dict, info, start, end, info.start + start, k); eachCb(obj.mark, { match : match, count : ++count, }); // matches the whole text node if (obj.increment === 0) break; // corrects the current index because new info object(s) were inserted into dict.nodes k += obj.increment; info = obj.nodeInfo; node = info.node; } else { node = this.wrapRange(node, start, end, node =&gt; { eachCb(node, { match : match, count : ++count }); }); } // with 'g' flag the lastIndex is required resetting; without 'g' flag it resets internally. regex.lastIndex = 0; if (execution.abort) break; } if (execution.abort) break; } endCb(count); }); } /** * Filter callback before each wrapping * @callback Mark~wrapMatchesAcrossFilterCallback * @param {Text} node - The text node where the match occurs or is part of the match * @param {string} str - The matching string * @param {Mark~filterInfoObject} filterInfo - The object containing the match information */ /** * Callback for each wrapped element * @callback Mark~wrapMatchesAcrossEachCallback * @param {HTMLElement} element - The marked DOM element * @param {Mark~eachInfoObject} - The object containing the match information */ /** * Callback on end * @callback Mark~wrapMatchesAcrossEndCallback * @param {number} count - The number of all matches */ /** * Wraps the instance element and class around matches across all HTML elements in all contexts * @param {RegExp} regex - The regular expression to be searched for * @param {number} ignoreGroups - A number of RegExp capturing groups to ignore from the beginning of a match * @param {Mark~wrapMatchesAcrossFilterCallback} filterCb - Filter callback * @param {Mark~wrapMatchesAcrossEachCallback} eachCb - Each callback * @param {Mark~wrapMatchesAcrossEndCallback} endCb * @access protected */ wrapMatchesAcross(regex, ignoreGroups, filterCb, eachCb, endCb) { const index = ignoreGroups === 0 ? 0 : ignoreGroups + 1, execution = { abort : false }, filterInfo = { execution : execution }; let match, str, matchStart, count = 0; this.getTextNodesAcross(dict =&gt; { while ((match = regex.exec(dict.text)) !== null &amp;&amp; (str = match[index]) !== '') { filterInfo.match = match; matchStart = true; // calculates the start index inside dict.text let i = 0, start = match.index; while (++i &lt; index) { if (match[i]) { // allows any ignore group to be undefined start += match[i].length; } } this.wrapRangeAcross(dict, start, start + str.length, obj =&gt; { // filter filterInfo.matchStart = matchStart; filterInfo.offset = obj.startOffset; matchStart = false; return filterCb(obj.node, str, filterInfo); }, (node, mStart) =&gt; { // each if (mStart) { count++; } eachCb(node, { match : match, matchStart : mStart, count : count, }); }); if (execution.abort) break; } endCb(count); }); } /** * Callback for each wrapped element * @callback Mark~wrapRangesEachCallback * @param {HTMLElement} element - The marked DOM element * @param {Mark~rangeObject} range - the current range object; the start and length values can be * modified if they are not numeric integers * @param {Mark~rangeInfoObject} rangeInfo - The object containing the range information */ /** * Filter callback before each wrapping * @callback Mark~wrapRangesFilterCallback * @param {Text} node - The text node which includes the range or is part of the range * @param {Mark~rangeObject} range - the current range object * @param {string} substr - string extracted from the matching range * @param {number} index - The current range index ??? */ /** * Callback on end * @callback Mark~wrapRangesEndCallback * @param {number} count - The number of wrapped ranges * @param {Mark~logObject[]} logs - The array of objects */ /** * Wraps the indicated ranges across all HTML elements in all contexts * @param {Mark~setOfRanges} ranges * @param {Mark~wrapRangesFilterCallback} filterCb * @param {Mark~wrapRangesEachCallback} eachCb * @param {Mark~wrapRangesEndCallback} endCb * @access protected */ wrapRanges(ranges, filterCb, eachCb, endCb) { const lines = this.opt.markLines, logs = [], skipped = [], level = 'warn'; let count = 0; this.getTextNodes(dict =&gt; { const max = lines ? dict.newLines.length : dict.text.length, array = this.checkRanges(ranges, logs, lines ? 1 : 0, max); array.forEach((range, index) =&gt; { let start = range.start, end = start + range.length; if (end &gt; max) { // with wrapAllRanges option, there can be several report of limited ranges logs.push({ text : `Range was limited to: ${max}`, obj : range, skip : true, level }); end = max; } if (lines) { start = dict.newLines[start-1]; if (dict.text[start] === '\\n') { start++; } end = dict.newLines[end-1]; } const substr = dict.text.substring(start, end); if (substr.trim()) { this.wrapRangeAcross(dict, start, end, obj =&gt; { // filter return filterCb(obj.node, range, substr, index); }, (node, rangeStart) =&gt; { // each if (rangeStart) { count++; } eachCb(node, range, { matchStart : rangeStart, count : count }); }); } else { // whitespace only; even if wrapped it is not visible logs.push({ text : 'Skipping whitespace only range: ', obj : range, level }); skipped.push(range); } }); this.log(`Valid ranges: ${JSON.stringify(array.filter(range =&gt; skipped.indexOf(range) === -1))}`); endCb(count, logs); }); } /** * Unwraps the specified DOM node with its content (text nodes or HTML) * without destroying possibly present events (using innerHTML) and normalizes text nodes * @param {HTMLElement} node - The DOM node to unwrap * @access protected */ unwrapMatches(node) { const parent = node.parentNode, first = node.firstChild; if (node.childNodes.length === 1) { // unwraps and normalizes text nodes if (first.nodeType === 3) { // the most common case - mark element with child text node const previous = node.previousSibling, next = node.nextSibling; if (previous &amp;&amp; previous.nodeType === 3) { if (next &amp;&amp; next.nodeType === 3) { previous.nodeValue += first.nodeValue + next.nodeValue; parent.removeChild(next); } else { previous.nodeValue += first.nodeValue; } } else if (next &amp;&amp; next.nodeType === 3) { next.nodeValue = first.nodeValue + next.nodeValue; } else { parent.replaceChild(node.firstChild, node); return; } parent.removeChild(node); } else { // most likely is a nested mark element or modified by user element parent.replaceChild(node.firstChild, node); } } else { if ( !first) { // an empty mark element parent.removeChild(node); } else { // most likely is a nested mark element(s) with sibling text node(s) or modified by user element(s) let docFrag = this.opt.window.document.createDocumentFragment(); while (node.firstChild) { docFrag.appendChild(node.removeChild(node.firstChild)); } parent.replaceChild(docFrag, node); } parent.normalize(); } } /** * Callback to filter matches * @callback Mark~markRegExpFilterCallback * @param {Text} node - The text node which includes the match or with acrossElements option can be part of the match * @param {string} match - The matching string: * 1) without 'ignoreGroups' and 'separateGroups' options - the whole match. * 2) with 'ignoreGroups' option - the match[ignoreGroups+1] group matching string. * 3) with 'separateGroups' option - the current group matching string * @param {number} matchesSoFar - The number of wrapped matches so far * @param {Mark~filterInfoObject} filterInfo - The object containing the match information. */ /** * Callback for each marked element * @callback Mark~markRegExpEachCallback * @param {HTMLElement} element - The marked DOM element * @param {Mark~eachInfoObject} eachInfo - The object containing the match information. */ /** * Callback if there were no matches * @callback Mark~markRegExpNoMatchCallback * @param {RegExp} regexp - The regular expression */ /** * These options also include the common options from {@link Mark~commonOptions} * @typedef Mark~markRegExpOptions * @type {object.&lt;string&gt;} * @property {number} [ignoreGroups=0] - A number of RegExp capturing groups to ignore from the beginning of a match * @property {boolean} [separateGroups] - Whether to mark RegExp capturing groups instead of whole match * @property {Mark~markRegExpNoMatchCallback} [noMatch] * @property {Mark~markRegExpFilterCallback} [filter] * @property {Mark~markRegExpEachCallback} [each] */ /** * Marks a custom regular expression * @param {RegExp} regexp - The regular expression * @param {Mark~markRegExpOptions} [opt] - Optional options object * @access public */ markRegExp(regexp, opt) { this.checkOption(opt); let totalMarks = 0, matchesSoFar = 0, fn = this.opt.separateGroups ? 'wrapSeparateGroups' : 'wrapMatches'; if (this.opt.acrossElements) { fn += 'Across'; // creates wrapSeparateGroupsAcross or wrapMatchesAcross // it solves the backward-compatibility issue but open gate for new code to slip in without g flag if ( !regexp.global &amp;&amp; !regexp.sticky) { let splits = regexp.toString().split('/'); regexp = new RegExp(regexp.source, 'g' + splits[splits.length-1]); this.log('RegExp is recompiled - it must have a `g` flag'); } } this.log(`RegExp &quot;${regexp}&quot;`); this[fn](regexp, this.opt.ignoreGroups, (node, match, filterInfo) =&gt; { // filter return this.opt.filter(node, match, matchesSoFar, filterInfo); }, (element, eachInfo) =&gt; { // each matchesSoFar = eachInfo.count; totalMarks++; this.opt.each(element, eachInfo); }, (totalMatches) =&gt; { // done if (totalMatches === 0) { this.opt.noMatch(regexp); } this.opt.done(totalMarks, totalMatches); }); } /** * Callback to filter matches * @callback Mark~markFilterCallback * @param {Text} node - The text node which includes the match or with acrossElements option can be part of the match * @param {string} term - The current term * @param {number} matches - The number of all wrapped matches so far * @param {number} termMatches - The number of wrapped matches for the current term so far * @param {Mark~filterInfoObject} filterInfo - The object containing the match information. */ /** * Callback for each marked element * @callback Mark~markEachCallback * @param {HTMLElement} element - The marked DOM element * @param {Mark~eachInfoObject} eachInfo - The object containing the match information. */ /** * Callback if there were no matches * @callback Mark~markNoMatchCallback * @param {string|string[]} term - Not found search term(s) */ /** * Callback when finished * @callback Mark~commonDoneCallback * @param {number} totalMarks - The total number of marked elements * @param {number} totalMatches - The total number of matches * @param {object} termStats - The object containing an individual term's matches counts for {@link Mark#mark} method */ /** * These options also include the common options from {@link Mark~commonOptions} * and the options from {@link RegExpCreator~options} * @typedef Mark~markOptions * @type {object.&lt;string&gt;} * @property {boolean} [separateWordSearch=true] - Whether to break term into words * and search for individual word instead of the complete term * @property {Mark~markFilterCallback} [filter] */ /** * Marks the specified search terms * @param {string|string[]} [sv] - A search string or an array of search strings * @param {Mark~markOptions} [opt] - Optional options object * @access public */ mark(sv, opt) { this.checkOption(opt); const { terms, termStats } = this.getSeachTerms(sv); if ( !terms.length) { this.opt.done(0, 0, termStats); return; } if (this.opt.combinePatterns) { this.markCombinePatterns(terms, termStats); return; } let index = 0, totalMarks = 0, matches = 0, totalMatches = 0, termMatches; const regCreator = new RegExpCreator(this.opt), fn = this.opt.acrossElements ? 'wrapMatchesAcross' : 'wrapMatches'; const loop = term =&gt; { termMatches = 0; const regex = regCreator.create(term); this.log(`RegExp &quot;${regex}&quot;`); this[fn](regex, 1, (node, t, filterInfo) =&gt; { // filter matches = totalMatches + termMatches; return this.opt.filter(node, term, matches, termMatches, filterInfo); }, (element, eachInfo) =&gt; { // each termMatches = eachInfo.count; totalMarks++; this.opt.each(element, eachInfo); }, (count) =&gt; { // end totalMatches += count; if (count === 0) { this.opt.noMatch(term); } termStats[term] = count; if (++index &lt; terms.length) { loop(terms[index]); } else { this.opt.done(totalMarks, totalMatches, termStats); } }); }; loop(terms[index]); } /** * Marks the specified search terms * @param {string[]} terms - An array of search terms * @param {object} termStats - An object for collecting terms statistics * @access protected */ markCombinePatterns(terms, termStats) { let index = 0, totalMarks = 0, totalMatches = 0, term, termMatches; const across = this.opt.acrossElements, fn = across ? 'wrapMatchesAcross' : 'wrapMatches', flags = `g${this.opt.caseSensitive ? '' : 'i'}`, patterns = this.getPatterns(terms); const loop = ({ pattern, regTerms }) =&gt; { const regex = new RegExp(pattern, flags); this.log(`RegExp &quot;${regex}&quot;`); this[fn](regex, 1, (node, t, filterInfo) =&gt; { // filter if ( !across || filterInfo.matchStart) { term = this.getCurrentTerm(filterInfo.match, regTerms); } // termStats[term] is the number of wrapped matches so far for the current term termMatches = termStats[term]; return this.opt.filter(node, term, totalMatches + termMatches, termMatches, filterInfo); }, (element, eachInfo) =&gt; { // each totalMarks++; if ( !across || eachInfo.matchStart) { termStats[term] += 1; } this.opt.each(element, eachInfo); }, (count) =&gt; { // end totalMatches += count; const array = regTerms.filter((term) =&gt; termStats[term] === 0); if (array.length) { this.opt.noMatch(array); } if (++index &lt; patterns.length) { loop(patterns[index]); } else { this.opt.done(totalMarks, totalMatches, termStats); } }); }; loop(patterns[index]); } /** * @param {array} match - The result of RegExp exec() method * @param {array} terms - The array of strings * @return {string} - The matched term */ getCurrentTerm(match, terms) { // it's better to search from the end of array because the terms sorted by // their length in descending order - shorter term appears more frequently let i = match.length; while (--i &gt; 2) { // the current term index is the first not undefined capturing group index minus three if (match[i]) { // the first 3 groups are: match[0], lookbehind, and main group return terms[i-3]; } } return ' '; } /** * Splits an array of string into chunks by the specified number and * combines each chunk strings into single RegExp pattern * @param {array} terms - The array of strings * @return {array} - The array of combined RegExp patterns */ getPatterns(terms) { const creator = new RegExpCreator(this.opt), option = this.opt.combinePatterns, array = []; let num = 10, value; if (option === Infinity) { num = Math.pow(2, 31); } else if (Number.isInteger(option) &amp;&amp; (value = parseInt(option)) &gt; 0) { num = value; } // the number of chunks to be created const count = Math.ceil(terms.length / num); for (let i = 0; i &lt; count; i++) { const start = i * num, // get a chunk of terms to create combine pattern slice = terms.slice(start, Math.min(start + num, terms.length)), obj = creator.createCombinePattern(slice, true); array.push({ pattern : `${obj.lookbehind}(${obj.pattern})${obj.lookahead}`, regTerms : slice }); } return array; } /** * @typedef Mark~rangeObject * @type {object} * @property {number} start - The start index within the composite string * @property {number} length - The length of the string to mark within the composite string. */ /** * @typedef Mark~setOfRanges * @type {object[]} * @property {Mark~rangeObject} */ /** * @typedef Mark~rangeInfoObject * @type {object} * @property {boolean} matchStart - Indicate the start of range * @property {number} count - The current number of wrapped ranges */ /** * These options also include the common options from {@link Mark~commonOptions} * @typedef Mark~markRangesOptions * @type {object.&lt;string&gt;} * @property {Mark~markRangesEachCallback} [each] * @property {Mark~markRangesNoMatchCallback} [noMatch] * @property {Mark~markRangesFilterCallback} [filter] */ /** * Callback to filter matches * @callback Mark~markRangesFilterCallback * @param {Text} node - The text node which includes the range or is part of the range * @param {Mark~rangeObject} range - The range object * @param {string} match - The current range matching string * @param {number} index - The current range index ??? */ /** * Callback for each marked element * @callback Mark~markRangesEachCallback * @param {HTMLElement} element - The marked DOM element * @param {Mark~rangeObject} range - The range object * @param {Mark~rangeInfoObject} - The object containing the range information */ /** * Callback if a processed range is invalid, out-of-bounds, overlaps another * range, or only matches whitespace * @callback Mark~markRangesNoMatchCallback * @param {Mark~rangeObject} range - The range object */ /** * Marks an array of objects containing start and length properties * @param {Mark~setOfRanges} ranges - The original array of objects * @param {Mark~markRangesOptions} [opt] - Optional options object * @access public */ markRanges(ranges, opt) { this.checkOption(opt, true); if (Array.isArray(ranges) &amp;&amp; ranges.some(obj =&gt; obj.start &amp;&amp; obj.length)) { let totalMarks = 0; this.wrapRanges(ranges, (node, range, match, index) =&gt; { // filter return this.opt.filter(node, range, match, index); }, (elem, range, rangeInfo) =&gt; { // each totalMarks++; this.opt.each(elem, range, rangeInfo); }, (totalRanges, logs) =&gt; { // end this.report(logs); this.opt.done(totalMarks, totalRanges); }); } else { this.report([{ text : 'markRanges() accept an array of objects: ', obj : ranges, level : 'error' }]); this.opt.done(0, 0); } } /** * Removes all marked elements inside the context with their HTML and normalizes text nodes * @param {Mark~commonOptions} [opt] - Optional options object without each, * noMatch and acrossElements properties * @access public */ unmark(opt) { this.checkOption(opt, true); let selector = this.opt.element + '[data-markjs]'; if (this.opt.className) { selector += `.${this.opt.className}`; } this.log(`Removal selector &quot;${selector}&quot;`); this.iterator.forEachNode(this.filter.SHOW_ELEMENT, node =&gt; { // each this.unwrapMatches(node); }, node =&gt; { // filter return DOMIterator.matches(node, selector) &amp;&amp; !this.excluded(node); }, this.opt.done); } } export default Mark;",7],
["markRanges() method∎Syntax∎// javascript const instance = new Mark(context); instance.markRanges(ranges[, options]); // jQuery $(context).markRanges(ranges[, options]);∎Parameters:∎ranges object[] - An array of objects with start and length properties with integer type values.∎options object - Optional options:∎Option∎Type∎Default∎Description∎element∎string∎mark∎A custom mark element e.g. span.∎className∎string∎''∎A custom class to be added to mark elements.∎exclude∎string or string[]∎[]∎A string or an array of selectors. Specifies DOM elements that should be excluded from searching.∎See exclude option for more details.∎wrapAllRanges∎boolean∎undefined∎Mark nesting/overlapping capturing groups∎See Marking nesting and overlapping ranges and match groups for more details.∎shadowDOM∎boolean∎undefined∎Whether to mark inside shadow DOMs∎See Highlighting in shadow DOM for more details.∎markLines∎boolean∎undefined∎Whether to mark ranges of lines instead of ranges of texts∎See Highlighting line ranges for more details.∎iframes∎boolean∎false∎Whether to mark inside iframes∎iframesTimeout∎number∎5000 ms∎The max time to wait for iframe(s) to load before skipping∎debug∎boolean∎false∎Whether to log messages∎log∎object∎console∎Log messages to a specific object∎filter∎function∎A callback to filter matches. It calls for each range (if a range is located across several elements, it calls for each text node which is part of the range) filter : (textNode, range, matchString, index) =&gt; {}∎textNode Text - The text node which includes the range or is the part of the range∎range object - The current range object∎matchString string - The current range matching string∎index number - The current range index (is not reliable - range can be skipped if it matches the string that contains only white spaces)∎The function must return either true (to wrap) or false (to skip wrapping mark element).∎each∎function∎A callback for each marked element each : (markElement, range, rangeInfo) =&gt; {}∎markElement HTMLElement - The marked DOM element∎range object - The range object∎rangeInfo object:∎matchStart boolean - indicate the start of a range;∎count number - The number of wrapped ranges so far∎done∎function∎A callback on finish done : (totalMarks, totalRanges) =&gt; {}∎totalMarks number - The total number of marked elements∎totalRanges number - The number of total ranges∎noMatch∎function∎A callback that is called on non-valid range noMatch : (range) =&gt; {}∎range string - The stringify range∎Example with default options values∎const options = { element : 'mark', className : '', exclude : [], wrapAllRanges : false, markLines : false, shadowDOM : false, iframes : false, iframesTimeout : 5000, filter : (textNode, range, matchingString, index) =&gt; { return true; // must return either true or false }, each : (markElement, range, rangeInfo) =&gt; {}, done : (totalMarks, totalMatches) =&gt; {}, noMatch : (range) =&gt; {}, debug : false, log : window.console };∎JavaScript:∎const instance = new Mark(document.querySelector('selector')), ranges = [{ start: 0, length: 5 }, { start: 6, length: 5 }]; instance.markRanges(ranges, options);∎jQuery:∎$('selector').markRanges(ranges, options);",8],
["markRegExp() method∎Syntax∎// javascript const instance = new Mark(context); instance.markRegExp(regex[, options]); // jQuery $(context).markRegExp(regex[, options]);∎Parameters:∎regex RegExp - The regular expression. With acrossElements option it must have g flag - it works with indexes and only two g and y flags allow control RegExp lastIndex. Note that for backward compatibility, RegExp without g flag is recompile internally with g flag. Although without acrossElements option it doesn't require g flag, it still recommended having this flag for future changes.∎options object - Optional options:∎Option∎Type∎Default∎Description∎element∎string∎mark∎A custom mark element e.g. span.∎className∎string∎''∎A custom class to be added to mark elements.∎exclude∎string or string[]∎[]∎A string or an array of selectors. Specifies DOM elements that should be excluded from searching.∎See exclude option for more details.∎ignoreGroups∎number∎0∎The number of adjacent capturing groups that should be ignored from the start of RegExp∎e.g. /(\\w+)(.)(\\w+)(?!\\2)/g, ignoreGroups : 2 - mark the group 3∎separateGroups∎boolean∎false∎Whether to mark RegExp capturing groups instead of whole match∎See Highlighting separate groups for more details.∎acrossElements∎boolean∎false∎Whether to search for matches across elements∎See acrossElements option for more details.∎wrapAllRanges∎boolean∎undefined∎Mark nesting/overlapping capturing groups∎See Marking nesting and overlapping ranges and match groups for more details.∎blockElementsBoundary∎boolean or object∎undefined∎Whether to limit matches within default HTML block elements and/or custom elements∎See Elements boundaries for more details.∎tagNames string[] - An array of custom HTML tag names∎extend boolean - true extends default boundary elements by the custom elements otherwise only the custom elements do have boundaries∎char string - A custom boundary character. The default is \\x01.∎shadowDOM∎boolean∎undefined∎Whether to mark inside shadow DOMs∎See Highlighting in shadow DOM for more details.∎iframes∎boolean∎false∎Whether to mark inside iframes∎iframesTimeout∎number∎5000 ms∎The max time to wait for iframe(s) to load before skipping∎debug∎boolean∎false∎Whether to log messages∎log∎object∎console∎Log messages to a specific object∎filter∎function∎A callback to filter matches. It calls for each match (with acrossElements option, if the match is located across several elements, it calls for each text node which is part of the match) filter : (textNode, matchString, matchesSoFar, filterInfo) =&gt; {}∎textNode Text - The text node which includes the match or with acrossElements option can be part of the match∎matchString string - The matching string:∎without ignoreGroups and separateGroups options - the whole match∎with ignoreGroups option - the match[ignoreGroups+1] group matching string, e.g. /(-)(\\w+)\\s+/g, ignoreGroups : 1, the matching string is content of the group 2∎with separateGroups option - the current group matching string∎matchesSoFar number - The number of all wrapped matches so far∎filterInfo object:∎match array - The result of RegExp exec() method∎matchStart boolean - indicate the start of a match AE∎groupIndex number - The current group index SG∎execution object - The helper object for early abort:∎abort boolean - Setting it to true breaks method execution∎offset number - When 'acrossElements: false': the absolute start index of a text node in joined context. When 'acrossElements: true': the sum of the lengths of separated spaces or boundary strings that were added to the composite string so far.∎The function must return either true (to wrap) or false (to skip wrapping mark element).∎each∎function∎A callback for each marked element each : (markElement, eachInfo) =&gt; {}∎markElement HTMLElement - The marked DOM element∎eachInfo object:∎match array - The result of RegExp exec() method∎matchStart boolean - Indicate the start of a match AE∎count number - The number of wrapped matches so far∎groupIndex number - The current index of match group SG∎groupStart boolean - Indicate the start of group AE SG∎done∎function∎A callback on finish. done : (totalMarks, totalMatches) =&gt; {}∎totalMarks number - The total number of marked elements∎totalMatches number - The total number of matches∎noMatch∎function∎A callback that is called when regex failed to match noMatch : (regex) =&gt; {}∎regex string - The stringify RegExp∎Available properties of the filterInfo object depending on options∎options∎match∎matchStart∎groupIndex∎execution∎offset∎acrossElements∎+∎+∎-∎+∎+∎acrossElements, separateGroups∎+∎+∎+∎+∎+∎separateGroups∎+∎+∎+∎+∎+∎above options are false∎+∎-∎-∎+∎+∎Available properties of the eachInfo object depending on options∎options∎match∎matchStart∎groupIndex∎groupStart∎count∎acrossElements∎+∎+∎-∎-∎+∎acrossElements, separateGroups∎+∎+∎+∎+∎+∎separateGroups∎+∎+∎+∎-∎+∎above options are false∎+∎-∎-∎-∎+∎Example with default options values∎const options = { element : 'mark', className : '', exclude : [], ignoreGroups : 0, acrossElements : false, wrapAllRanges : false, blockElementsBoundary : false, shadowDOM : false, iframes : false, iframesTimeout : 5000, filter : (textNode, matchString, matchesSoFar, filterInfo) =&gt; { return true; // must return either true or false }, each : (markElement, eachInfo) =&gt; {}, done : (totalMarks, totalMatches) =&gt; {}, noMatch : (regex) =&gt; {}, debug : false, log : window.console };∎JavaScript:∎const instance = new Mark(document.querySelector('selector')), regex = /../gi; instance.markRegExp(regex, options);∎jQuery:∎$('selector').markRegExp(regex, options);∎AE - only available when acrossElements option is set to true∎SG - only available when separateGroups option is set to true∎AE SG - only available when both acrossElements and separateGroups options are set to true",9],
["Nesting/overlapping ranges and match groups∎The markRanges() method with wrapAllRanges option, can mark nesting/overlapping ranges. With this option, all ranges that have indexes within 0 and context length be wrapped. The markRegExp() method with RegExp having the d flag, with separateGroups and wrapAllRanges options can mark: nesting groups, capturing groups inside positive lookaround assertions. It practically removes all restrictions. The lookaround examples demonstrate cases when wrapAllRanges option should be used, otherwise they won't be correctly highlighted:∎RegExp with lookaround assertions can create overlapping matches. e.g. regex /(?&lt;=(gr1)\\s+\\w+\\b).+?(gr2)/dg, string 'gr1 match1 gr1 gr2 match2 gr2'. The gr1 from the second match not wrapped because the gr2 from the first match is already wrapped.∎Another case: regex /(?=\\d*(1))(?=\\d*(2))(?=\\d*(3))/dg, matches '123, 132, 213, 231, 312, 321'. This is not an overlapping case, but groups are wrapped in any order. If group 1 is wrapped first, the 2 and 3 are ignored in '231, 321' ...∎Groups overlapping case: regex /\\w+(?=.*?(gr1 \\w+))(?=.*?(\\w+ gr2))/dg , string 'word gr1 overlap gr2' - the gr1 is wrapped, the gr2 is ignored.∎Note: the wrapAllRanges option can cause performance degradation if the context contains a very large number of text nodes and mark elements. This is because with each wrapping, two more objects are inserted into the array, which require a lot of copying, memory allocation ...∎The 8MB file containing 177000 text nodes:∎option∎marked groups 2500∎marked groups 29000∎wrapAllRanges: true∎0.7 sec.∎2.9 sec.∎wrapAllRanges: false∎0.65 sec.∎0.7 sec.∎The 1MB file containing 20800 text nodes:∎option∎marked groups 2500∎marked groups 29000∎wrapAllRanges: true∎120 ms.∎710 ms.∎wrapAllRanges: false∎70 ms.∎310 ms.∎Note: wrapAllRanges option with d flag wraps all capturing groups regardless of nested level. You need to filter out unwanted groups. Without this option - if a group has been wrapped, all nested groups are ignored.∎To mark nesting/overlapping ranges.∎const ranges = [{ start: 0, length: 50 }, { start: 10, length: 20, nested: true }, ..]; instance.markRanges(ranges, { 'wrapAllRanges' : true, 'each' : (markElement, range) =&gt; { // to distinguish ranges you can add some property to ranges if (range.nested) { markElement.className = 'nested'; } } });∎To mark nesting groups with acrossElements option and d flag.∎instance.markRegExp(/\\w+\\s((nested group)\\s+\\w+)/dg, { 'acrossElements' : true, 'separateGroups' : true, 'wrapAllRanges' : true, 'each' : (markElement, info) =&gt; { if (info.groupIndex === 2) { markElement.className = 'nested'; } } });∎To mark nesting groups with acrossElements option and RegExp without d flag∎It treats the whole match as a group 0, and all child groups, in this case 'group1, group2', as nested ones. It's an only way to wrap nested groups without `d` flag:∎let regex = /\\w+\\s(group1).+?(group2).*/gi; instance.markRegExp(regex, { 'acrossElements' : true, 'separateGroups' : true, 'wrapAllRanges' : true, 'each' : (markElement, info) =&gt; { if (info.groupIndex === 0) { markElement.className = 'main-group'; } if (info.groupIndex &gt; 0) { markElement.className = 'nested-group'; } } });∎Simple example with next/previous buttons.∎It uses numbers as unique match identifiers in continuous ascending order. The code example with next/previous buttons which uses 'start elements' doesn't work correctly with nesting/overlapping matches.∎let currentIndex = 0, matchCount, marks, // highlight 3 words in sentences in any order, e.g. 'word word2 word word3 word word1.' regex = /(?=[^.]*?(word1))(?=[^.]*?(word2))(?=[^.]*?(word3))/dgi; instance.markRegExp(regex, { 'acrossElements' : true, 'separateGroups' : true, 'wrapAllRanges' : true, 'each' : (markElement, info) =&gt; { // info.count as a match identifier markElement.setAttribute('data-markjs', info.count); }, 'done' : (totalMarks, totalMatches) =&gt; { marks = $('mark'); matchCount = totalMatches; } }); prevButton.click(function() { if (--currentIndex &lt;= 0) currentIndex = 0; highlightMatchGroups(); }); nextButton.click(function() { if (++currentIndex &gt; matchCount) currentIndex = matchCount; highlightMatchGroups(); }); function highlightMatchGroups() { marks.removeClass('current'); const elems = marks.filter((i, elem) =&gt; $(elem).data('markjs') === currentIndex).addClass('current'); elems.find('*[data-markjs]').addClass('current'); // add class to all descendant too }",10],
["Options descriptions∎Note: this is still under development.∎acrossElements option∎With this option the library aggregate all context(s) text node contents into a single string taking into account HTML elements. If a block element 'divides' two text nodes, and node.textContents doesn't separated by white space, the space is added to the string to separate them, e.g. '&lt;h1&gt;Header&lt;/h1&gt;&lt;p&gt;Paragraph&lt;/p&gt;' resulted in 'Header Paragraph' (in mark.js - 'HeaderParagraph').∎Due to searching in single string, it can highlight matches across HTML block elements, which in most cases are undesirable. A blockElementsBoundary option can be used to limit matches within HTML elements. See Elements boundaries for more details.∎separateWordSearch option∎When it set to true, if a searching string contains several words, it splits the string by spaces into separate words and highlights individual words instead of the whole string. It also applies to every string in a searching array.∎When it set to 'preserveTerms', it preserved term(s) surrounding by double quotes from breaking into separate words. This allows highlight exact term(s) alone side with individual words. It can be useful, when library is used to highlight searchings or in case of using a string instead of an array and there is need to keep some term(s) intact.∎It also allows highlight quoted terms no matter how many quotes it contains on each side (but not in the middle), e.g. &quot;&quot;term&quot;&quot; - marked &quot;term&quot;, &quot;&quot;&quot;&quot;term&quot; - &quot;&quot;&quot;term.∎exclude option∎In the case if the context contains element(s) matches in which shouldn't be highlighted, the exclude option can be pretty handy.∎&lt;section&gt; &lt;p&gt;Lorem ipsum dolor&lt;/p&gt; &lt;p&gt;Lorem ipsum dolor&lt;/p&gt; &lt;p&gt;Lorem &lt;i&gt;ipsum &lt;b&gt;dolor&lt;/b&gt;&lt;/i&gt;&lt;/p&gt; &lt;/section&gt;∎new Mark(document.querySelector(&quot;section&quot;)).mark(&quot;Lorem dolor&quot;, { // Note: to exclude all descendants, you need to add 'p:last-child *' selector exclude: 'p:last-child, p:last-child *' });∎accuracy option∎The option values specify how library should perform searching:∎partially (contains) - searches for matches within a text node content (AE - within an aggregated context string). Can highlight practically anything.∎exactly - the default word boundaries are:∎start - the start of a text node (AE - start of a context) and the built-in boundaries.∎end - the end of a text node (AE - end of a context) and the built-in boundaries.∎startsWith - the default word boundaries are:∎start - the start of a text node (AE - start of a context) and the built-in boundaries.∎end - searching will continued til built-in word boundaries or to the end of a text node content (AE - to the end of a context).∎complementary - the default word boundaries are:∎start - will search for the start of built-in boundaries or to the start of a text node content (AE - to the start of a context).∎end - searching will continued til built-in word boundaries or to the end of a text node content (AE - to the end of a context).∎The built-in word boundary characters are: white spaces and !&quot;#$%&amp;'`()*+,-./:;&lt;=&gt;?@[\\\\]^_{|}~¡¿.∎An accuracy object can be used if the default boundaries are not satisfactory:∎value: 'exactly' or 'startsWith' or 'complementary'∎limiters: a string or an array of custom word boundary characters, e.g. { value : 'exactly', limiters : &quot;,.;:?!'\\\\&quot;()&quot; }∎AE - with option acrossElements: true or acrossElements: inline.",11],
["Performance∎The performance results in Firefox compare to mark.js v8.11.1:∎markRegExp() method, acrossElements : true; marked words 3000∎library∎size 100KB∎size 200KB∎size 500KB∎size 1MB∎mark.js∎~350 ms.∎~680 ms.∎~1700 ms.∎~2800 ms.∎this∎~30 ms.∎~35 ms.∎~45 ms.∎~60 ms.∎the same without acrossElements option; marked words 3000∎library∎size 100KB∎size 200KB∎size 500KB∎size 1MB∎mark.js∎~30 ms.∎~40 ms.∎~70 ms.∎~110 ms.∎this∎~30 ms.∎~35 ms.∎~40 ms.∎~50 ms.∎markRanges() method, marked ranges - 3000∎library∎size 100KB∎size 200KB∎size 500KB∎size 1MB∎mark.js∎~220 ms.∎~350 ms.∎~970 ms.∎~1700 ms.∎this∎~36 ms.∎~40 ms.∎~51 ms.∎~60 ms.∎unmark() method, mark elements - 34500, size 1MB; mark time Firefox &amp; Chrome - ~360 ms∎library∎Firefox∎Chrome∎mark.js∎~1200 ms.∎~1300 ms.∎this∎~210 ms.∎~630 ms.∎Ways to boost performance∎Related highlighting a (especially) large array of strings or string with the separateWordSearch option. A mark() method highlights an array item by item, e.g. an array of 10 items is run 10 times. It isn't efficient.∎There are two options to boost performance :∎combinePatterns : combines given numbers of RegExp patterns into a single pattern, e.g. an array of 50 strings, combinePatterns : 10 - creates 5 combine patterns, so instead of 50 runs there are only 5 runs. Any number bigger than the array length or Infinity creates a single combined pattern. Note: with diacritics option, a single pattern can be monstrous and more slowly, it's better to create 5-7 patterns (it's probably related to a processor cache). Also, this option prevents highlighting inside already highlighted elements, but it only true for single combined pattern.∎cacheTextNodes : collecting text nodes information on every run is expensive. Caching this information improves performance with a large array. The performance gain gradually grows, starting with an array containing 2-3 items and doubled with 4-5 items. Note: this option does not change behavior as the combinePatterns option does. It can be used with existing code to improve performance.∎In Firefox marking an array of 500 words on a 1 MB page, 26500 text nodes, diacritics : false and ~7600 highlighted words :∎with combinePatterns : Infinity ~0.2 second. (single pattern)∎with cacheTextNodes option ~4.2 sec.∎with cacheTextNodes and acrossElements options ~1 sec.∎with acrossElements options ~21 sec.∎without above options ~19 sec.∎The same with diacritics:∎with combinePatterns : Infinity ~1.8 second. (single pattern)∎with combinePatterns : 100 ~0.4 second. (5 patterns)∎instance.mark([ 'str1', 'str2', .. ], { 'combinePatterns' : number // or true (default number is 10) });",12],
["RegExpCreator module∎It has three API methods:∎create()∎createCombinePattern()∎createDiacritics()∎create()∎The create(string, true) method with the second parameter set to true instead of RegExp, returns an object containing three properties:∎lookbehind - is actuality a capturing group; is non-empty group only with accuracy options: 'exactly' or { 'value' : 'exactly', 'limiters': .. }, and 'startsWith' or { 'value' : 'startsWith', 'limiters': .. }. It can be easily converted to lookbehind assertion by replacing the first ( by (?&lt;=.∎pattern - a string pattern∎lookahead - is real lookahead assertion pattern; is non-empty string only with accuracy option: 'exactly' or { 'value' : 'exactly', 'limiters': .. }. These properties can be used in options object: accuracy, diacritics, synonyms, caseSensitive, ignoreJoiners, ignorePunctuation, and wildcards.∎See mark() method for properties details.∎import RegExpCreator from './regexpcreator.es6.js'; const creator = new RegExpCreator(options); const obj = creator.create(string, true); console.log(obj.lookbehind, obj.pattern, obj.lookahead);∎createCombinePattern()∎The createCombinePattern(array, capture) method creates combine pattern from an array of string; returns an object containing three properties:∎lookbehind - is the same as in create() method;∎pattern - a combine pattern itself. If the capture parameter set to true, an individual pattern is wrapped in a capturing group, false - non-capturing group.∎lookahead - is the same as in create() method;∎// the 'creator' and the accepted options are the same as in above example const obj = creator.createCombinePattern(array, true); console.log(obj.pattern); // true - (ptn1)|(ptn2)|(ptn3); false - (?:ptn1)|(?:ptn2)|(?:ptn3)∎createDiacritics()∎The createDiacritics(string) method returns a string diacritic pattern. It's affected only by one option : caseSensitive.∎import creator from './regexpcreator.es6.js'; const pattern = new creator(options).createDiacritics(string); console.log(pattern);",13],
["RegExpCreator class∎/** * Creates regular expressions based on specified settings * @example * new RegExpCreator({caseSensitive: true, diacritics: false}).create('lorem'); * // =&gt; /()(lorem)/gm */ class RegExpCreator { /** * @typedef RegExpCreator~accuracyObj * @type {object.&lt;string&gt;} * @property {string} value - An accuracy string value * @property {string[]} limiters - A custom array of limiters. For example * &lt;code&gt;[&quot;-&quot;, &quot;,&quot;]&lt;/code&gt; */ /** * @typedef RegExpCreator~accuracy * @type {string} * @property {&quot;partially&quot;|&quot;complementary&quot;|&quot;exactly&quot;|RegExpCreator~accuracyObj} * [accuracy=&quot;partially&quot;] - Either one of the following string values: * &lt;ul&gt; * &lt;li&gt;&lt;i&gt;partially&lt;/i&gt;: When searching for &quot;lor&quot; only &quot;lor&quot; inside * &quot;lorem&quot; will be marked&lt;/li&gt; * &lt;li&gt;&lt;i&gt;complementary&lt;/i&gt;: When searching for &quot;lor&quot; the whole word * &quot;lorem&quot; will be marked&lt;/li&gt; * &lt;li&gt;&lt;i&gt;exactly&lt;/i&gt;: When searching for &quot;lor&quot; only those exact words * will be marked. In this example nothing inside &quot;lorem&quot;. * &lt;/ul&gt; * Or an object containing two properties: * &lt;ul&gt; * &lt;li&gt;&lt;i&gt;value&lt;/i&gt;: The value must be &quot;exactly&quot; or &quot;complementary&quot; or &quot;startsWith&quot;&lt;/li&gt; * &lt;li&gt;&lt;i&gt;limiters&lt;/i&gt;: A custom array of string limiters&lt;/li&gt; * &lt;/ul&gt; */ /** * @typedef RegExpCreator~wildcards * @type {string} * @property {&quot;disabled&quot;|&quot;enabled&quot;|&quot;withSpaces&quot;} * [wildcards=&quot;disabled&quot;] - Set to any of the following string values: * &lt;ul&gt; * &lt;li&gt;&lt;i&gt;disabled&lt;/i&gt;: Disable wildcard usage&lt;/li&gt; * &lt;li&gt;&lt;i&gt;enabled&lt;/i&gt;: When searching for &quot;lor?m&quot;, the &quot;?&quot; will match zero * or one non-space character (e.g. &quot;lorm&quot;, &quot;loram&quot;, &quot;lor3m&quot;, etc). When * searching for &quot;lor*m&quot;, the &quot;*&quot; will match zero or more non-space * characters (e.g. &quot;lorm&quot;, &quot;loram&quot;, &quot;lor123m&quot;, etc).&lt;/li&gt; * &lt;li&gt;&lt;i&gt;withSpaces&lt;/i&gt;: When searching for &quot;lor?m&quot;, the &quot;?&quot; will * match zero or one space or non-space character (e.g. &quot;lor m&quot;, &quot;loram&quot;, * etc). When searching for &quot;lor*m&quot;, the &quot;*&quot; will match zero or more space * or non-space characters (e.g. &quot;lorm&quot;, &quot;lore et dolor ipsum&quot;, &quot;lor: m&quot;, * etc).&lt;/li&gt; * &lt;/ul&gt; */ /** * @typedef RegExpCreator~ignorePunctuation * @type {string[]} * @property {string} The strings in this setting will contain punctuation * marks that will be ignored: * &lt;ul&gt; * &lt;li&gt;These punctuation marks can be between any characters, e.g. setting * this option to &lt;code&gt;[&quot;'&quot;]&lt;/code&gt; would match &quot;Worlds&quot;, &quot;World's&quot; and * &quot;Wo'rlds&quot;&lt;/li&gt; * &lt;li&gt;One or more apostrophes between the letters would still produce a * match (e.g. &quot;W'o''r'l'd's&quot;).&lt;/li&gt; * &lt;li&gt;A typical setting for this option could be as follows: * &lt;pre&gt;ignorePunctuation: &quot;:;.,- ‒_(){}[]!'\\\"+=&quot;.split(&quot;&quot;),&lt;/pre&gt; This * setting includes common punctuation as well as a minus, en-dash, * em-dash and figure-dash * ({@link https://en.wikipedia.org/wiki/Dash#Figure_dash ref}), as well * as an underscore.&lt;/li&gt; * &lt;/ul&gt; */ /** * @typedef RegExpCreator~options * @type {object.&lt;string&gt;} * @property {boolean} [diacritics=true] - If diacritic characters should be * matched. ({@link https://en.wikipedia.org/wiki/Diacritic Diacritics}) * @property {object.&lt;string|string[]&gt;} [synonyms] - An object with synonyms. * The key will be a synonym for the value and the value for the key * @property {RegExpCreator~accuracy} [accuracy] * @property {boolean} [caseSensitive=false] - Whether to search case sensitive * @property {boolean} [ignoreJoiners=false] - Whether to ignore word * joiners inside of key words. These include soft-hyphens, zero-width * space, zero-width non-joiners and zero-width joiners. * @property {RegExpCreator~ignorePunctuation} [ignorePunctuation] * @property {RegExpCreator~wildcards} [wildcards] */ /** * @typedef RegExpCreator~patternObj * @type {object} * @property {string} lookbehind - A lookbehind capturing group * @property {string} pattern - A string pattern * @property {string} lookahead - A positive lookahead assertion */ /** * @param {RegExpCreator~options} [options] - Optional options object */ constructor(options) { this.opt = Object.assign({}, { 'diacritics': true, 'synonyms': {}, 'accuracy': 'partially', 'caseSensitive': false, 'ignoreJoiners': false, 'ignorePunctuation': [], 'wildcards': 'disabled' }, options); } /** * The array with lower and upper cases diacritics characters * @type {string[]} * @access protected */ get chars() { if ( !this._chars) { this._chars = []; // initialises an array with lower and upper cases diacritics characters ['aàáảãạăằắẳẵặâầấẩẫậäåāą', 'cçćč', 'dđď', 'eèéẻẽẹêềếểễệëěēę', 'iìíỉĩịîïī', 'lł', 'nñňń', 'oòóỏõọôồốổỗộơởỡớờợöøōő', 'rř', 'sšśșş', 'tťțţ', 'uùúủũụưừứửữựûüůūű', 'yýỳỷỹỵÿ', 'zžżź'].forEach(str =&gt; { this._chars.push(str, str.toUpperCase()); }); } return this._chars; } /** * Creates a regular expression to match the specified search term considering * the available option settings * @param {string} str - The search term to be used * @param {boolean} patterns - Whether to return an object with pattern parts or RegExp object * @return {RegExpCreator~patternObj|RegExp} */ create(str, patterns) { const flags = 'g' + (this.opt.caseSensitive ? '' : 'i'); str = this.checkWildcardsEscape(str); str = this.createSynonyms(str, flags); const joiners = this.getJoinersPunctuation(); if (joiners) { str = this.setupIgnoreJoiners(str); } if (this.opt.diacritics) { str = this.createDiacritics(str); } str = str.replace(/\\s+/g, '[\\\\s]+'); if (joiners) { str = this.createJoiners(str, joiners); } if (this.opt.wildcards !== 'disabled') { str = this.createWildcards(str); } const obj = this.createAccuracy(str); return (patterns ? obj : new RegExp(`${obj.lookbehind}(${obj.pattern})${obj.lookahead}`, flags)); } /** * Creates a single combine pattern from an array of string considering the available option settings * @param {Array} array - The array of string * @param {boolean} capture - Whether to wrap an individual pattern in a capturing or non-capturing group * @return {RegExpCreator~patternObj|null} */ createCombinePattern(array, capture) { if ( !Array.isArray(array) || !array.length) { return null; } const group = capture ? '(' : '(?:', obj = this.create(array[0], true); obj.pattern = this.distinct(array.map(str =&gt; `${group}${this.create(str, true).pattern})`)).join('|'); return obj; } /** * Sort array from longest entry to shortest * @param {array} arry - The array to sort * @return {array} */ sortByLength(arry) { return arry.sort((a, b) =&gt; a.length === b.length ? // sort a-z for same length elements (a &gt; b ? 1 : -1) : b.length - a.length ); } /** * Escapes RegExp special characters * @param {string} str - The string to escape * @return {string} */ escape(str) { return str.replace(/[[\\]/{}()*+?.\\\\^$|]/g, '\\\\$&amp;'); } /** * Splits string if val is string, removes duplicates, escape '-^]\\\\' which are special in RegExp characters set * @param {array|string} val - The parameter to process * @return {string} */ preprocess(val) { if (val &amp;&amp; val.length) { return this.distinct(typeof val === 'string' ? val.split('') : val).join('').replace(/[-^\\]\\\\]/g, '\\\\$&amp;'); } return ''; } /** * Removes duplicate or empty entries * @param {array} array - The array to process * @return {array} */ distinct(array) { const result = []; array.forEach(item =&gt; { if (item.trim() &amp;&amp; result.indexOf(item) === -1) { result.push(item); } }); return result; } /** * Creates a regular expression string to match the defined synonyms * @param {string} str - The search term to be used * @return {string} */ createSynonyms(str, flags) { const syn = this.opt.synonyms; if ( !Object.keys(syn).length) { return str; } for (const key in syn) { if (syn.hasOwnProperty(key)) { let array = Array.isArray(syn[key]) ? syn[key] : [syn[key]]; array.unshift(key); array = this.sortByLength(this.distinct(array)).map(term =&gt; this.checkWildcardsEscape(term)); if (array.length &gt; 1) { const pattern = array.map(k =&gt; this.escape(k)).join('|'); str = str.replace(new RegExp(pattern, flags), `(?:${array.join('|')})`); } } } return str; } /** * Check wildcards option creates placeholders in the regular expression string to allow later * insertion of wildcard patterns and escapes RegExp special characters * @param {string} str - The search term * @return {string} */ checkWildcardsEscape(str) { if (this.opt.wildcards !== 'disabled') { // replaces single character wildcard with \\x01, multiple character wildcard with \\x02 str = str.replace(/(\\\\.)+|[?*]/g, (m, gr) =&gt; gr ? m : m === '?' ? '\\x01' : '\\x02') // removes one backslash character before '?', '*', '\\x01', and '\\x02' .replace(/\\\\+(?=[?*\\x01\\x02])/g, m =&gt; m.slice(1)); } return this.escape(str); } /** * Replaces the wildcard placeholders in a regular expression string * @param {string} str - The search term to be used * @return {string} */ createWildcards(str) { // default to &quot;enable&quot; (i.e. to not include spaces) // &quot;withSpaces&quot; uses `[^]` instead of `.` because the latter does not match new line characters // or `[^\\x01]` if blockElementsBoundary option is enabled const spaces = this.opt.wildcards === 'withSpaces', boundary = this.opt.blockElementsBoundary, anyChar = `[^${spaces &amp;&amp; boundary ? '\\x01' : ''}]*?`; return str // replace \\x01 with a RegExp class to match any single // character, or any single non-whitespace character depending // on the setting .replace(/\\x01/g, spaces ? '[^]?' : '\\\\S?') // replace \\x02 with a RegExp class to match zero or // more characters, or zero or more non-whitespace characters // depending on the setting .replace(/\\x02/g, spaces ? anyChar : '\\\\S*'); } /** * Creates placeholders in the regular expression string to allow later insertion of * designated characters (soft hyphens, zero width characters, and punctuation) * @param {string} str - The search term to be used * @return {string} */ setupIgnoreJoiners(str) { // it's not added '\\0' after `(?:` grouping construct, around `|` char and wildcard `\\x02` placeholder, // before `)` char, and at the end of a string, // not breaks the grouping construct `(?:`, continues pairs of backslashes, and UTF-16 surrogate pairs const reg = /((?:\\\\\\\\)+|\\x02|\\(\\?:|\\|)|\\\\?(?:[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|.)(?=([|)\\x02]|$)|.)/g; return str.replace(reg, (m, gr1, gr2) =&gt; { return gr1 || typeof gr2 !== 'undefined' ? m : m + '\\x00'; }); } /** * Replaces '\\x00' placeholders in a regular expression string by designated * characters (soft hyphens, zero width characters, and punctuation) based on the * specified option values of &lt;code&gt;ignorePunctuation&lt;/code&gt; and * &lt;code&gt;ignoreJoiners&lt;/code&gt; * @param {string} str - The search term to be used * @return {string} */ createJoiners(str, joiners) { return str.split(/\\x00+/).join(`[${joiners}]*`); } /** * Creates a punctuation and/or joiners pattern * @return {string} */ getJoinersPunctuation() { let punct = this.preprocess(this.opt.ignorePunctuation), str = punct ? punct : ''; if (this.opt.ignoreJoiners) { // u+00ad = soft hyphen // u+200b = zero-width space // u+200c = zero-width non-joiner // u+200d = zero-width joiner str += '\\\\u00ad\\\\u200b\\\\u200c\\\\u200d'; } return str; } /** * Creates a regular expression string to match diacritics * @param {string} str - The search term to be used * @return {string} */ createDiacritics(str) { const array = this.chars; return str.split('').map(ch =&gt; { for (let i = 0; i &lt; array.length; i += 2) { const lowerCase = array[i].indexOf(ch) !== -1; if (this.opt.caseSensitive) { if (lowerCase) { return '[' + array[i] + ']'; } else if (array[i+1].indexOf(ch) !== -1) { return '[' + array[i+1] + ']'; } } else if (lowerCase || array[i+1].indexOf(ch) !== -1) { return '[' + array[i] + array[i+1] + ']'; } } return ch; }).join(''); } /** * Creates a regular expression string to match the specified string with the * defined accuracy. All regular expressions created with two capturing groups. * The first group is ignored (serves as lookbehind with values 'exactly' and 'startsWith'), * the second is contained the actual match * @param {string} str - The search term to be used * @return {RegExpCreator~patternObj} */ createAccuracy(str) { const chars = '!&quot;#$%&amp;\\'()*+,\\\\-./:;&lt;=&gt;?@[\\\\]\\\\\\\\^_`{|}~¡¿'; let accuracy = this.opt.accuracy, lookbehind = '()', pattern = str, lookahead = '', limiters; if (typeof accuracy !== 'string') { limiters = this.preprocess(accuracy.limiters); accuracy = accuracy.value; } if (accuracy === 'exactly') { const charSet = limiters ? '[\\\\s' + limiters + ']' : '\\\\s'; lookbehind = `(^|${charSet})`; lookahead = `(?=$|${charSet})`; } else { const chs = limiters ? limiters : chars, charSet = `[^\\\\s${chs}]*`; if (accuracy === 'complementary') { pattern = charSet + str + charSet; } else if (accuracy === 'startsWith') { lookbehind = `(^|[\\\\s${chs}])`; pattern = str.replace(/\\[\\\\s\\]\\+/g, charSet + '$&amp;') + charSet; } } return { lookbehind, pattern, lookahead }; } } export default RegExpCreator;",14],
["Highlighting separate groups∎Important: in this implementation two branches of code process separate groups, which one, depending on the existence of d flag.∎Primitive, base on indexOf(), only reliable with contiguous groups - unwanted group(s) can be easily filtered out.∎Exact, but not all browsers currently supported group indices.∎Case without wrapAllRanges option:∎They both have identical logic for nested groups - if a parent group has been marked, there is no way to mark nested groups. This means you can use a nested group(s) as auxiliary and don't care about filtering them.∎Case wrapAllRanges : true:∎With acrossElements option, the primitive one wrap a whole match as a group 0 and then all groups that are child of match[0] as a nested (see Example).∎The exact one wrap all nested groups - you need to filter nested an auxiliary group(s).∎They have different parent groups logic:∎The exact one does allow using a parent group as an auxiliary - you need to filter out it in order to mark a nested group(s).∎The primitive one does not allow this - if a parent group has filtered out, a nested group(s) won't be marked.∎To test the primitive branch compatibility, just add the d flag.∎There is no strict requirement for the contiguity of capturing groups. Compare: string - 'AAB xxx BCD xx BC', to mark groups AB and BC∎in /(AB)\\b.+?\\b(BC)/g the indexOf('BC', start) find first 'BC', which is correct∎in /(AB)\\b(.+?)\\b(BC)(?!D)/g the indexOf('BC', start) also find first 'BC', which is wrong, because of condition '(?!D)', so group 2 is required.∎Warning: related using RegExp without the d flag:∎Do not add a capturing group(s) to lookbehind assertion (?&lt;=), there is no code which handles such cases.∎With acrossElements option, it is not possible to highlight a capturing group(s) inside a lookahead assertion (?=).∎See markRegExp() method about info object properties used in filter and each callbacks. How to filter matches see Filtering matches. How to highlight nesting groups see Nesting groups.∎Filtering capturing groups:∎instance.markRegExp(/(AB)\\b(.+)\\b(?&lt;gr3&gt;CD)?(.+)(EF)\\b/gi, { // 'acrossElements' : true, 'separateGroups' : true, 'filter' : (textNode, matchString, matchesSoFar, info) =&gt; { // To filter any group use info.groupIndex - a current group index // Note: if a group lays across several elements, the index be the same while a group is wrapping if (info.groupIndex === 2 || info.groupIndex === 4) return false; // also can be used a group content // if (matchString === 'AB') return false; // To filter a whole match on a group presence // Note: it iterates through all groups and only then returns if (info.match[3]) return true/false; // or // also can be used a named capturing group if (info.match.groups.gr3) return true/false; return true; }, });∎Example to mark separate groups with acrossElements option:∎let groupCount = 0, gr1Count = 0, gr2Count = 0; instance.markRegExp(/(AB)\\b.+?\\b(CD)/gi, { 'acrossElements' : true, 'separateGroups' : true, 'each' : (markElement, info) =&gt; { // info.count - matches count so far // if start of match group if (info.groupStart) { // all group count groupCount++; // info.groupIndex is the index of a current match group if (info.groupIndex === 1) { markElement.className = 'group1-1'; gr1Count++; } else if (info.groupIndex === 2) { markElement.className = 'group2-1'; gr2Count++; } } } });∎Example to mark separate groups without acrossElements option:∎let count = 0, gr1Count = 0; instance.markRegExp(/(AB).+?(CD)/gi, { 'separateGroups' : true, 'each' : (markElement, info) =&gt; { // all group count count++; if (info.groupIndex === 1) { // an individual group count gr1Count++; } } });",15],
["Highlighting in shadow DOM∎An option shadowDOM : trueallows to highlight a text inside shadow DOMs that have mode: 'open' and are already created. You can play with Playground - Examples -&gt; Shadow DOM.∎Note: to style mark elements in shadow DOM, the option shadowDOM : {style : 'your mark element style'} can be used. It creates a style element and inserts it at the beginning of shadow root child node(s). But this operation is invasive, it can break the root code. An inline style can be used as an alternative:∎each : (markElement, info) =&gt; { // a shadow root is the DocumentFragment if (markElement.getRootNode().nodeType === Node.DOCUMENT_FRAGMENT_NODE) { markElement.style.color = &quot;red&quot;; } }",16],
["Code examples of using each and done callbacks∎See mark() each callback about callback info object properties.∎In mark() method with acrossElements option∎let matchCount = 0; instance.mark(['AB CD', 'EF'], { 'acrossElements' : true, 'each' : (markElement, info) =&gt; { // sets external counter matchCount = info.count; // internal use if (info.count ..) {} // if start of the match if(info.matchStart) { markElement.className = 'start-1'; // markElement.setAttribute('data-markjs', 'start-1'); // to use the attribute instead of class // matchCount++; // to use the custom counter instead of info.count } }, 'done' : (totalMarks, totalMatches, termStats) =&gt; { for (const term in termStats) { console.log(term + ' = ' + termStats[term]); } } });∎In mark() method without acrossElements option∎let matchCount = 0; context.mark('AB CD EF', { 'separateWordSearch' : true, 'each' : (markElement, info) =&gt; { // for external counter matchCount = info.count; // also possible matchCount++; // for internal use if(info.count ..) {} }, 'done' : (totalMarks, totalMatches, termStats) =&gt; { console.log('Total matches = ' + totalMatches); for(var term in termStats) { console.log(term + ' = ' + termStats[term]); } } });∎In markRegExp() method with acrossElements option∎See markRegExp() each callback about callback info object properties.∎let matchCount = 0; instance.markRegExp(/.../gi, { 'acrossElements' : true, 'each' : (markElement, info) =&gt; { // usage of info.count and custom counter are the same // as in mark() method with `acrossElements` option // use of info.count as a unique match identifier markElement.setAttribute('data-markjs', info.count); }, 'done' : (totalMarks, totalMatches) =&gt; { console.log('Total matches = ' + totalMatches); } });∎Simple example with next/previous buttons∎Unusable with markRegExp() method having wrapAllRanges option. See Example with next/previous buttons that can be used for this case.∎let currentIndex = 0, marks = $('mark'), startElements = marks.filter((i, elem) =&gt; $(elem).hasClass('start-1')); //startElements = marks.filter((i, elem) =&gt; $(elem).data('markjs') === 'start-1'); prevButton.on('click', function() { if (--currentIndex &lt;= 0) currentIndex = 0; let elem = startElements.eq(currentIndex); if (elem.length) highlightMatch(elem[0]); }); nextButton.on('click', function() { if (++currentIndex &gt;= startElements.length) currentIndex = startElements.length - 1; let elem = startElements.eq(currentIndex); if (elem.length) highlightMatch(elem[0]); }); // adds class 'current' to all mark elements of the found match if it located across elements // or to the first mark element function highlightMatch(elem) { let found = false; marks.each((i, el) =&gt; { if ( !found) { if (el === elem[0]) found = true; // start of the next 'start element' means the end of the current match } else if ($(el).hasClass('start-1')) return false; //} else if ($(el).data('markjs') === 'start-1') return false; if (found){ $(el).addClass('current'); $(el).find('*[data-markjs]').addClass('current'); // add class to all descendant too } }); }",17],
["TypeScript types∎The following TypeScript declaration files are added to dist folder:∎mark.d.ts∎mark.es6.d.ts∎jquery.mark.d.ts∎jquery.mark.es6.d.ts∎node.jquery.mark.es6.d.ts∎regexpcreator.d.ts∎regexpcreator.es6.d.ts∎Note: the default imported library is ES6 module -mark.es6.js, to import others you need to specify the full path, e.g. import 'advanced-mark.js/dist/jquery.mark.js';.∎JavaScript example∎// imported 'mark.es6.js' library import Mark from 'advanced-mark.js'; new Mark(document.querySelector(&quot;article&quot;)).mark('lorem ipsum', {});∎jQuery example∎Note: in Node.js environment with jquery you need to use node.jquery.mark.es6.js module, which contains necessary import $ from 'jquery' declaration.∎import $ from 'jquery'; import 'advanced-mark.js/dist/jquery.mark.js'; $(&quot;article&quot;).mark('lorem ipsum', {});",18],
["unmark() method∎Syntax∎// javascript const instance = new Mark(context); instance.unmark([options]); // jQuery $(context).unmark([options]);∎Parameters:∎options object - Optional options:∎Option∎Type∎Default∎Description∎element∎string∎mark∎Specifies marked elements to remove.∎Important: if other than default marked element is used, e.g. span, it must be also specified in the unmark() method. It is also possible to use * in case of using different marked elements to unmark in one run. A mark.js library uses a default selector *[data-markjs] but it is not safe to apply to all HTML elements.∎className∎string∎''∎Remove only marked elements with specified class name.∎exclude∎string or string[]∎[]∎A string or an array of selectors. Specifies DOM elements that should be excluded from searching.∎shadowDOM∎boolean∎undefined∎Whether to remove marked elements inside shadow DOMs∎Note: if the shadowDOM option is used with highlighting method, it must be also specified in the unmark() method. See Highlighting in shadow DOM for more details.∎iframes∎boolean∎false∎Whether to search inside iframes∎Note: if the iframes option is used with highlighting method, it must be also specified in the unmark() method.∎iframesTimeout∎number∎5000 ms∎The max time to wait for iframe(s) to load before skipping∎debug∎boolean∎false∎Whether to log messages∎log∎object∎console∎Log messages to a specific object∎done∎function∎A callback after all specified marked elements were removed done : () =&gt; {}∎It has no parameters.∎Example with default options values∎const options = { element : 'mark', className : '', shadowDOM : false, iframes : false, iframesTimeout : 5000, done : () =&gt; {}, debug : false, log : window.console };∎JavaScript:∎var instance = new Mark(document.querySelector('selector')); instance.unmark(options);∎jQuery:∎$('selector').unmark(options);",19],
];
var SearchIndex = {"domiterator":[0,32,7,8,4,1],"class":[7,6,14,4,4,3,17,3,0,2,6,1,8,1,9,1,10,1,19,1],"a":[7,58,14,26,6,23,11,20,15,20,0,17,9,12,8,10,12,8,3,6,1,5,10,5,13,5,19,5,16,3,5,1,17,1],"nodeiterator":[0,4],"with":[7,37,12,13,10,12,14,11,9,8,1,7,6,6,17,6,5,5,0,4,15,4,19,4,8,3,11,3,13,3,2,2,3,2,16,1,18,1],"iframes":[0,11,19,4,6,3,7,3,8,3,9,3],"support":[0,1],"and":[7,40,14,16,6,14,10,8,9,7,11,7,15,5,0,4,12,4,8,3,13,3,3,2,4,2,16,2,17,2,1,1,2,1,5,1],"method":[7,13,13,6,19,6,17,5,4,4,6,4,9,4,12,4,2,3,0,2,10,2,5,1,8,1,15,1],"to":[7,80,14,28,6,22,9,20,11,17,15,14,0,12,8,12,19,11,3,9,2,8,10,8,12,6,17,5,18,4,1,3,13,3,16,2],"check":[7,4,0,2,14,1],"if":[7,137,0,45,14,24,17,14,2,12,15,12,10,9,11,4,5,3,19,3,8,2,1,1,6,1,9,1,13,1,16,1],"an":[7,26,6,11,0,9,14,8,12,5,11,4,13,4,15,3,16,3,3,2,5,2,8,2,9,2,10,2,1,1,19,1],"element":[7,67,0,25,6,6,8,6,9,6,1,3,3,3,19,3,11,2,16,2,17,2],"is":[7,38,0,10,6,10,15,9,9,8,13,7,10,6,1,5,8,5,19,5,11,4,14,4,5,3,12,3,16,2,2,1,3,1,18,1],"matching":[7,14,9,4,0,1,8,1],"specified":[0,7,7,5,19,5,14,4,5,1,6,1],"selector":[0,12,7,8,19,3,6,2,8,2,9,2,3,1,11,1],"example":[7,3,14,3,15,3,10,2,17,2,18,2,0,1,1,1,6,1,8,1,9,1,13,1,19,1],"const":[7,45,0,19,14,15,13,4,8,3,9,3,6,2,10,2,19,2,5,1,17,1],"iterator":[0,6,7,4],"new":[7,17,14,4,3,2,6,2,8,2,9,2,13,2,19,2,0,1,5,1,11,1,18,1],"document":[0,8,7,6,3,5,5,1,6,1,8,1,9,1,11,1,18,1,19,1],"queryselector":[0,3,7,2,3,1,5,1,6,1,8,1,9,1,11,1,18,1,19,1],"context":[0,14,11,9,7,6,6,4,9,3,3,2,8,2,10,2,19,2,1,1,17,1],"true":[7,21,6,14,2,13,10,13,9,9,15,9,1,8,0,6,13,6,14,5,17,4,8,3,12,3,11,2,5,1],"foreachnode":[7,3,0,2],"nodefilter":[0,6,7,1],"show_text":[0,2,7,2],"node":[7,215,0,43,11,9,6,4,9,3,18,3,3,2,8,2,16,2,1,1],"each":[7,54,0,7,6,7,17,7,8,6,9,6,10,5,15,3,2,2,4,1,5,1,11,1,16,1],"console":[17,4,0,3,13,3,6,2,7,2,8,2,9,2,19,2],"log":[7,20,6,4,8,4,9,4,17,4,19,4,0,3,13,3],"filter":[7,51,0,13,2,13,15,7,6,4,8,4,9,4,10,2,17,2],"return":[7,58,14,38,0,17,2,12,15,5,6,3,8,3,9,3,17,2],"matches":[7,32,6,10,0,8,2,8,9,6,11,4,10,3,15,3,8,2,17,2,1,1,4,1],"parentnode":[7,7,0,1],"ignore":[7,5,0,1,14,1],"done":[0,12,7,12,17,4,6,3,8,3,9,3,19,3,4,1,5,1,10,1],"param":[7,188,0,35,14,16],"htmlelement":[7,20,0,18,6,1,8,1,9,1],"nodelist":[0,5,7,4,3,1],"string":[7,82,14,54,6,23,9,14,11,10,8,9,13,8,0,7,19,5,1,3,10,2,3,1,12,1,15,1],"ctx":[0,28,7,5],"the":[7,370,0,50,14,46,6,42,9,40,11,28,8,18,10,18,15,14,2,12,13,11,17,9,12,7,19,6,3,5,16,4,1,3,5,3,18,3],"dom":[7,29,0,19,6,3,8,3,9,3,16,3,19,2,4,1],"array":[7,66,14,42,0,18,6,9,12,8,9,4,11,3,13,3,3,2,8,2,1,1,10,1,19,1],"of":[7,115,6,25,9,23,11,17,14,13,8,11,17,9,0,8,15,7,12,6,10,3,2,2,5,2,13,2,19,2,1,1,3,1,4,1,16,1],"elements":[7,19,1,13,6,11,9,11,19,7,0,6,5,4,8,4,11,4,10,2,12,2,17,2,3,1,4,1,14,1,15,1,16,1],"or":[7,30,6,24,14,19,0,9,9,8,11,8,8,5,1,4,12,3,13,3,3,2,19,2,5,1,15,1,17,1],"object":[7,87,6,17,14,11,9,10,8,9,0,4,13,3,19,3,1,2,2,2,17,2,3,1,11,1,15,1],"opt":[7,74,0,18,14,12],"options":[7,16,9,16,6,12,8,8,19,8,14,6,13,5,12,4,0,2,4,1,10,1,11,1],"constructor":[0,1,7,1,14,1],"instance":[7,6,2,4,3,4,6,4,8,4,9,4,10,4,19,4,15,3,1,2,5,2,17,2,0,1,12,1],"either":[6,3,0,2,7,2,8,2,9,2,14,1],"type":[7,52,14,7,0,4,8,2,6,1,9,1,19,1],"access":[7,24,0,15,2,1,14,1],"protected":[7,20,0,10,14,1],"this":[7,155,0,41,14,41,12,7,10,5,11,3,15,3,1,1,5,1,6,1,9,1,16,1,17,1],"containing":[7,25,0,2,10,2,13,2,3,1,6,1,12,1,14,1],"mark":[7,180,3,20,6,17,18,17,2,13,9,12,8,11,12,9,17,9,10,7,15,5,19,5,5,3,11,3,4,2,16,2,0,1,1,1,13,1],"name":[7,6,0,5,19,1],"attribute":[0,2,3,1,17,1],"which":[7,7,15,4,6,2,8,2,9,2,10,2,11,2,0,1,14,1,18,1],"added":[7,6,0,2,1,2,6,2,9,2,8,1,11,1,14,1,18,1],"indicate":[7,8,9,3,6,2,0,1,8,1],"iframe":[0,40,7,4,1,1,6,1,8,1,9,1,19,1],"state":[0,1],"attrname":[0,8],"data":[17,5,0,4,10,3,7,2,19,1],"markjslistener":[0,1],"checks":[0,3,7,3],"selectors":[7,4,0,3,6,1,8,1,9,1,19,1],"boolean":[7,17,6,16,9,12,8,6,0,5,14,5,19,3,1,1],"public":[7,5,0,2],"static":[0,1],"length":[7,57,14,10,0,5,17,4,8,3,10,3,3,1,5,1,12,1],"false":[7,27,6,19,9,15,8,9,2,8,0,5,14,5,19,5,15,4,17,3,1,2,10,2,13,2,12,1],"typeof":[7,4,14,3,0,2],"fn":[7,11,0,3],"matchesselector":[0,1],"msmatchesselector":[0,1],"mozmatchesselector":[0,1],"omatchesselector":[0,1],"webkitmatchesselector":[0,1],"some":[0,2,7,1,10,1,11,1],"sel":[0,2],"call":[0,2],"returns":[13,3,7,2,0,1,15,1],"all":[7,18,0,8,10,6,15,6,1,2,6,2,11,2,17,2,19,2,9,1,14,1],"contexts":[0,8,7,4],"filtered":[7,4,15,2,0,1],"by":[7,15,3,4,0,3,11,3,13,3,6,2,9,1,12,1,14,1],"duplicates":[0,1,14,1],"nested":[10,10,15,8,7,7,0,3],"getcontexts":[0,2],"let":[7,36,17,7,0,6,2,4,14,4,10,2,15,2,5,1],"sort":[0,4,14,4,7,3],"window":[7,12,0,6,6,1,8,1,9,1,19,1],"prototype":[0,1],"isprototypeof":[0,1],"isarray":[7,2,14,2,0,1],"else":[7,27,0,9,14,4,2,2,17,2,15,1],"queryselectorall":[0,2,3,2],"e":[7,14,6,7,14,7,0,6,9,3,11,3,3,2,10,2,12,2,1,1,8,1,18,1,19,1],"g":[14,16,7,10,9,10,6,7,11,3,0,2,3,2,10,2,12,2,15,2,1,1,8,1,18,1,19,1],"inside":[7,7,14,3,6,2,8,2,9,2,19,2,0,1,10,1,12,1,15,1,16,1],"filters":[7,4,0,1],"out":[7,7,15,3,0,1,10,1],"duplicate":[0,1,7,1,14,1],"foreach":[7,8,0,4,14,2],"elem":[17,12,0,11,7,6,5,4,10,2],"indexof":[7,7,14,4,15,3,0,1],"contains":[7,5,11,4,3,2,0,1,8,1,10,1,18,1],"push":[7,16,0,3,14,2],"in":[7,16,11,16,14,9,10,6,17,6,19,6,13,5,15,5,6,4,0,3,2,3,3,3,5,2,9,2,12,2,16,2,1,1,4,1,8,1,18,1],"custom":[1,11,7,11,6,8,9,7,0,3,3,2,8,2,14,2,17,2,11,1],"can":[7,8,11,6,10,5,0,4,5,4,15,4,16,4,3,2,6,2,12,2,13,2,1,1,2,1,8,1,9,1,14,1,17,1],"be":[7,22,14,16,6,5,11,5,15,5,9,4,19,4,0,3,8,3,10,3,12,2,13,2,16,2,3,1,5,1,17,1],"any":[7,6,6,4,14,4,0,2,10,2,12,1,15,1],"order":[10,3,0,2,7,2,15,1],"sorts":[7,2,0,1],"b":[15,9,7,4,14,4,0,2,11,2,10,1],"comparedocumentposition":[0,1],"document_position_following":[0,1],"callback":[7,97,0,30,2,7,6,4,8,4,9,4,17,4,19,1],"getiframecontentssuccesscallback":[0,3],"htmldocument":[0,2],"contents":[0,2,1,1,11,1],"contentdocument":[0,2],"calls":[0,6,7,4,6,2,8,2,9,2,3,1],"success":[0,3],"function":[6,5,8,5,9,5,0,4,10,3,17,3,7,1,19,1],"it":[7,26,11,9,9,7,19,6,12,5,0,4,5,4,10,4,6,3,8,3,13,3,15,3,16,3,1,1,2,1,14,1,17,1],"t":[7,6,0,3,10,2,11,2,15,2,5,1,9,1,12,1],"accessed":[0,2],"error":[0,8,7,4],"ifr":[0,21],"successfn":[0,11],"errorfn":[0,12],"getiframecontents":[0,4],"try":[0,2],"doc":[0,3],"contentwindow":[0,3],"setattribute":[0,4,7,2,17,2,10,1],"completed":[0,2],"catch":[0,2],"empty":[7,10,13,2,0,1,14,1],"about":[0,4,15,2,17,2,2,1],"blank":[0,3],"shown":[0,1],"page":[0,1,3,1,5,1,12,1],"isiframeblank":[0,2],"bl":[0,3],"src":[0,4,3,2,4,1],"getattribute":[0,2],"trim":[7,2,0,1,14,1],"href":[0,4],"location":[0,2],"observes":[0,1],"onload":[0,1],"event":[0,3,7,1],"inaccessible":[0,1],"isn":[0,1,5,1,12,1],"fired":[0,4],"within":[7,8,11,3,0,1,6,1,9,1,10,1],"link":[7,13,0,5,14,2],"iframestimeout":[0,3,6,2,7,2,8,2,9,2,19,2],"then":[15,2,0,1],"ll":[0,1],"too":[0,1,10,1,17,1],"observeiframeload":[0,3],"listener":[0,5],"already":[7,4,0,2,10,1,12,1,16,1],"hasattribute":[0,3],"id":[0,5],"null":[7,11,14,2,0,1],"cleartimeout":[0,2],"removeeventlistener":[0,1],"load":[0,2,6,1,7,1,8,1,9,1,19,1],"addeventlistener":[0,1],"settimeout":[0,2],"when":[7,13,0,7,14,7,9,6,6,5,11,3,1,1,10,1],"ready":[0,7],"oniframereadysuccesscallback":[0,2],"oniframereadyerrorcallback":[0,2],"for":[7,38,6,18,9,14,14,14,8,8,0,7,17,5,11,3,15,2,19,2,3,1,5,1,12,1,13,1],"see":[6,9,9,6,0,4,8,4,15,4,17,3,2,2,7,1,11,1,13,1,19,1],"http":[0,3,7,1],"stackoverflow":[0,1,7,1],"com":[0,3,7,1],"background":[0,1],"information":[7,14,12,2,0,1,6,1],"oniframeready":[0,2],"readystate":[0,1],"complete":[0,1,7,1],"accessing":[0,1],"failed":[0,1,9,1],"are":[11,6,6,4,7,4,10,4,9,3,0,2,1,2,12,2,3,1,13,1,14,1,15,1,16,1,17,1,18,1],"waitforiframesdonecallback":[0,2],"iterates":[0,3,15,1],"over":[0,2],"them":[7,3,0,1,1,1,11,1,15,1],"including":[0,2,7,2],"ones":[0,1,7,1,10,1],"waitforalliframes":[0,2],"donecb":[0,6],"count":[7,43,2,17,17,8,15,7,0,3,6,3,9,2,10,2,8,1],"not":[7,5,14,4,15,4,0,2,10,2,11,2,6,1,8,1,12,1,19,1],"sure":[0,1],"timeout":[0,1],"should":[9,2,0,1,6,1,8,1,10,1,11,1,14,1,19,1],"guarantee":[0,1],"single":[12,6,14,4,7,3,3,2,11,2,0,1,1,1],"something":[0,1,7,1],"went":[0,1,7,1],"wrong":[0,1,7,1,15,1],"checkdone":[0,3],"hasattributevalue":[0,3],"loop":[7,10,0,3],"obj":[7,57,0,12,14,8,13,6],"body":[0,1,1,1,7,1],"exclude":[7,5,11,4,6,3,8,3,9,3,0,2,19,1],"case":[7,7,10,4,11,2,15,2,0,1,6,1,14,1,17,1,19,1],"main":[7,7,0,1,1,1,10,1],"has":[7,5,0,3,15,2,6,1,10,1,13,1,19,1],"no":[0,4,7,3,15,3,6,1,11,1,19,1],"were":[7,7,0,3,6,1,9,1,19,1],"handled":[0,3],"unmark":[19,9,0,2,7,2,3,1,4,1,12,1],"debug":[7,8,6,2,8,2,9,2,19,2,0,1],"creates":[14,9,7,5,12,2,0,1,13,1,16,1],"on":[7,8,14,4,6,3,9,3,15,3,3,2,8,2,12,2,17,2,0,1,2,1,11,1],"https":[14,2,0,1],"developer":[0,1],"mozilla":[0,1],"org":[14,2,0,1],"en":[14,3,0,1],"docs":[0,1],"web":[0,1,3,1],"api":[3,4,0,1,4,1,13,1],"whattoshow":[0,17],"filtercb":[7,30,0,9],"createiterator":[0,3],"createnodeiterator":[0,1],"adds":[0,1,7,1,17,1],"style":[0,11,16,6,7,1],"shadow":[0,9,16,6,6,2,8,2,9,2,19,2,4,1],"root":[0,10,16,3],"marking":[0,1,7,1,8,1,9,1,12,1],"removes":[14,3,7,2,0,1,10,1],"there":[7,5,15,3,0,2,12,2,3,1,11,1],"possibility":[0,2],"whether":[6,8,7,6,9,6,8,4,14,4,19,3,0,2,1,1],"though":[0,1],"add":[0,4,7,4,10,2,15,2,3,1,11,1,17,1],"indicating":[0,1],"remove":[19,3,0,1,3,1],"addremovestyle":[0,2],"firstchild":[7,5,0,2],"markjs":[17,5,0,3,10,3,7,2,19,1],"createelement":[0,1,7,1],"textcontent":[7,15,0,1],"insertbefore":[0,1],"removechild":[7,4,0,1],"value":[7,18,14,7,6,6,0,3,13,3,11,2],"through":[0,1,15,1],"nodes":[7,53,0,3,10,3,12,2,1,1,11,1],"foreachnodecallback":[0,3],"eachcb":[7,35,0,5],"foreachnodeendcallback":[0,3],"end":[7,91,11,9,0,3,6,2,14,1,17,1],"iteratethroughnodes":[0,2],"shadowdom":[19,3,6,2,8,2,9,2,16,2,0,1],"showelement":[0,2],"show_element":[7,3,0,2],"showtext":[0,4],"traverse":[0,4],"while":[7,14,0,2,15,1],"nextnode":[0,2],"nodetype":[7,6,0,2,16,1],"nodename":[7,3,0,1],"tolowercase":[7,5,0,1],"whole":[7,6,6,2,9,2,15,2,0,1,10,1,11,1,14,1],"because":[7,2,10,2,0,1,6,1,14,1,15,1],"working":[0,1],"neither":[0,1],"shadowroot":[0,5],"itself":[0,1,6,1,13,1],"mode":[0,1,16,1],"open":[0,5,7,3,16,1],"text":[7,126,11,9,6,5,9,4,0,3,8,3,10,3,1,2,5,2,12,2,3,1,16,1],"typedef":[7,17,14,6,0,1],"tinyurl":[0,2],"number":[7,83,6,14,9,14,8,8,12,3,0,1,2,1,5,1,10,1,19,1],"accept":[0,1,7,1],"reject":[0,1],"process":[14,2,0,1,15,1],"export":[0,1,7,1,14,1],"default":[1,10,6,6,9,5,11,4,19,4,7,3,8,2,14,2,0,1,12,1,18,1],"boundaries":[11,11,6,4,1,3,9,2,4,1],"note":[3,2,10,2,11,2,12,2,15,2,18,2,19,2,1,1,5,1,9,1,16,1],"that":[7,8,9,5,6,4,8,3,1,1,3,1,5,1,10,1,14,1,15,1,16,1,17,1,19,1],"using":[7,4,1,2,15,2,2,1,3,1,4,1,11,1,17,1,19,1],"blockelementsboundary":[1,8,6,2,9,2,14,2,7,1,11,1],"option":[7,26,9,11,6,10,10,10,11,9,12,7,14,7,1,5,15,5,17,5,2,4,5,3,19,3,8,2,13,2,16,2,3,1],"only":[7,17,9,5,2,4,1,3,13,3,6,2,12,2,14,2,15,2,8,1,10,1,19,1],"makes":[1,1],"sense":[1,1],"acrosselements":[9,15,6,13,7,13,2,6,15,6,17,6,10,5,12,4,1,3,11,3],"highlighting":[4,3,19,3,8,2,9,2,12,2,1,1,5,1,6,1,15,1,16,1],"phrases":[1,1],"regexp":[7,47,14,9,9,8,10,3,2,2,6,2,1,1,12,1,13,1,15,1],"capturing":[7,12,15,5,14,4,9,3,13,3,2,2,10,2,1,1,8,1],"groups":[7,28,15,17,10,16,9,5,2,2,4,2,8,2,1,1,14,1],"wildcards":[14,9,6,3,1,2,13,1],"character":[6,9,14,7,1,2,9,1],"withspaces":[14,4,1,1,6,1],"match":[7,130,6,18,9,17,14,14,15,7,10,6,2,5,17,4,1,1,4,1,8,1],"multiple":[1,1,3,1,7,1,14,1],"words":[6,5,11,5,12,4,7,2,14,2,1,1,10,1],"how":[7,2,11,2,15,2,1,1],"library":[12,4,11,3,3,2,18,2,1,1,19,1],"aggregates":[1,1],"s":[7,38,14,12,15,7,6,5,10,5,11,5,1,3,9,2,12,2,2,1,8,1,13,1,16,1,19,1],"into":[7,8,11,4,6,3,1,1,5,1,10,1,12,1],"block":[1,6,11,2,6,1,7,1,9,1],"divides":[1,1,11,1],"two":[7,6,6,2,14,2,1,1,9,1,10,1,11,1,12,1,15,1],"spaces":[14,5,6,3,11,2,1,1,7,1,8,1,9,1],"depends":[1,1],"between":[2,4,14,2,1,1,7,1],"header":[1,3,11,2,7,1],"p":[11,11,1,4,7,1],"paragraph":[1,2,11,2],"resulted":[1,1,11,1],"different":[1,1,7,1,15,1,19,1],"values":[14,4,6,2,7,2,8,2,1,1,9,1,11,1,19,1],"allows":[7,6,11,2,1,1],"across":[7,17,6,2,9,2,1,1,8,1,11,1,15,1,17,1],"html":[7,10,11,3,6,2,9,2,1,1,3,1,19,1],"except":[1,3],"tagnames":[1,5,7,4,6,1,9,1],"extend":[1,4,7,4,6,1,9,1],"boundary":[7,20,6,4,1,3,9,3,11,2,14,2],"tag":[7,4,1,2,6,1,9,1],"names":[7,6,1,1,6,1,9,1],"undefined":[7,4,6,3,8,3,9,3,1,1,14,1,19,1],"make":[1,1],"have":[7,3,1,2,9,2,15,2,2,1,3,1,6,1,10,1,16,1],"char":[7,6,1,4,14,2,6,1,9,1],"lorem":[14,5,11,4,3,2,7,2,18,2,1,1],"ipsum":[11,3,18,2,1,1,7,1,14,1],"dolor":[11,4,1,1,14,1],"separatewordsearch":[7,4,6,3,1,1,11,1,12,1,17,1],"these":[7,4,14,2,1,1,13,1],"div":[1,2,3,1,7,1],"optional":[7,6,1,2,6,1,8,1,9,1,14,1,19,1],"extending":[1,1],"markregexp":[9,5,2,4,10,4,15,4,17,4,7,3,1,1,3,1,4,1,12,1],"gi":[15,3,2,2,1,1,9,1,10,1,17,1],"tab":[1,1],"container":[1,1],"address":[1,1,7,1],"area":[1,1,7,1],"article":[18,2,1,1,7,1],"aside":[1,1,7,1],"audio":[1,1,7,1],"blockquote":[1,1,7,1],"br":[7,4,5,2,1,1],"button":[1,1,7,1],"canvas":[1,1,7,1],"dd":[1,1,7,1],"details":[6,8,9,6,8,4,1,1,7,1,11,1,13,1,19,1],"dl":[1,1,7,1],"dt":[1,1,7,1],"fieldset":[1,1,7,1],"figcaption":[1,1,7,1],"figure":[1,1,7,1,14,1],"footer":[1,1,7,1],"form":[1,1,7,1],"hr":[1,1,7,1],"img":[1,1,7,1],"input":[7,3,1,1],"label":[1,1,7,1],"li":[14,21,1,1,7,1],"map":[14,4,7,2,1,1],"menu":[1,1,7,1],"menuitem":[1,1,7,1],"meter":[1,1,7,1],"nav":[1,1,7,1],"ol":[1,1,7,1],"output":[1,1,7,1],"picture":[1,1,7,1],"pre":[5,2,14,2,1,1,6,1,7,1],"section":[11,3,1,1,7,1],"select":[1,1,7,1],"svg":[1,1,7,1],"table":[1,1,7,1],"tbody":[1,1,7,1],"td":[1,1,7,1],"textarea":[1,1,7,1],"tfoot":[1,1,7,1],"th":[1,1,7,1],"thead":[1,1,7,1],"tr":[1,1,7,1],"track":[1,1,7,1],"ul":[14,8,1,1,7,1],"video":[1,1,7,1],"filtering":[15,3,2,2,4,1,6,1],"info":[7,35,2,15,15,15,17,14,10,8,5,2,16,1],"properties":[7,6,13,4,6,3,9,2,17,2,2,1,3,1,8,1,14,1,15,1],"ab":[15,7,2,2,17,2],"textnode":[2,3,6,3,8,3,9,3,15,1],"term":[7,31,6,14,14,11,11,7,17,6,2,2],"matchessofar":[7,4,2,3,9,3,6,2,15,1],"termmatchessofar":[2,2,6,2],"first":[7,10,2,7,10,2,15,2,13,1,14,1,17,1],"execution":[7,19,2,7,6,3,9,3],"abort":[7,13,2,7,6,2,9,2],"requires":[2,2,3,1,7,1],"its":[2,2,7,1],"own":[2,2],"counter":[17,4,2,3],"matchstart":[7,16,6,4,9,4,2,2,5,1,8,1,17,1],"skip":[2,2,7,2,6,1,8,1,9,1],"without":[7,6,9,3,10,3,15,3,12,2,2,1,17,1],"difference":[2,1],"implementation":[2,1,15,1],"reg":[2,7,7,2,14,2],"you":[15,3,2,2,3,2,10,2,18,2,5,1,11,1,16,1],"also":[7,5,19,4,15,3,11,2,2,1,12,1,17,1],"used":[7,7,14,7,11,3,15,3,19,3,5,2,6,2,16,2,2,1,10,1,12,1,13,1,17,1],"lastindex":[7,32,2,3,9,1],"infinity":[2,3,12,3,7,2],"instead":[7,3,11,2,17,2,2,1,5,1,8,1,9,1,12,1,13,1,14,1],"matchstring":[9,3,8,2,15,2,2,1],"desired":[2,1],"much":[2,1],"more":[6,10,9,6,14,5,8,4,2,1,7,1,10,1,11,1,12,1,19,1],"limited":[7,2,2,1],"than":[2,1,7,1,12,1,19,1],"markelement":[10,9,17,6,15,4,5,3,6,3,8,3,9,3,16,3,2,1],"getting":[3,1,4,1],"started":[3,1,4,1],"download":[3,1],"package":[3,1],"npm":[3,2],"running":[3,1],"install":[3,1],"advanced":[18,3,3,1],"js":[3,16,18,9,12,5,7,2,13,2,11,1,19,1],"save":[3,1],"dev":[3,1],"dist":[18,3,3,1],"directory":[3,1],"files":[3,2,18,1],"javascript":[3,2,6,2,8,2,9,2,19,2,18,1],"min":[3,5,7,3],"jquery":[3,11,18,10,6,2,8,2,9,2,19,2],"use":[17,5,3,2,15,2,6,1,18,1,19,1],"virtual":[3,1],"doms":[3,1,6,1,8,1,9,1,16,1,19,1],"necessary":[7,5,3,1,18,1],"import":[18,6,7,2,13,2,3,1],"from":[7,18,13,3,18,3,6,2,9,2,10,2,14,2,3,1,8,1,11,1,19,1],"declaration":[3,2,18,2],"typescript":[18,2,3,1,4,1],"d":[10,8,18,7,15,5,3,4,14,1],"include":[7,3,14,2,3,1],"just":[3,1,15,1],"script":[3,4,7,1],"path":[3,2,18,1],"utf":[3,2,14,1],"encoding":[3,1],"may":[3,1,7,1],"needs":[3,1],"adding":[3,1],"charset":[14,8,3,2,7,1],"four":[3,1],"methods":[3,3,7,2,13,1],"highlight":[11,5,3,3,5,2,15,2,7,1,10,1,16,1],"terms":[7,27,3,1,11,1],"regular":[7,10,14,10,3,1,9,1],"expressions":[14,2,3,1],"markranges":[7,6,8,5,5,2,10,2,3,1,4,1,12,1],"ranges":[7,21,8,12,10,8,5,4,4,2,3,1,9,1,12,1],"start":[7,129,11,10,17,9,6,5,9,5,8,4,10,3,15,3,5,2,3,1],"lines":[7,9,3,1,5,1,8,1],"marklines":[5,2,7,2,8,2,3,1],"highlights":[3,1,11,1,12,1],"called":[3,2,6,1,8,1,9,1],"initialize":[3,1],"var":[3,1,6,1,17,1,19,1],"where":[7,18,3,1],"get":[7,3,3,2,14,1],"getelementbyid":[3,1],"internally":[3,2,7,1,9,1],"sorted":[3,1,7,1],"position":[7,9,3,1],"every":[3,1,7,1,11,1,12,1],"test":[6,2,7,2,3,1,15,1],"content":[11,4,4,1,6,1,7,1,9,1,15,1],"usage":[4,1,14,1,17,1],"performance":[12,7,6,3,4,1,10,1],"descriptions":[4,1,11,1],"separate":[7,10,15,4,11,3,6,2,4,1,9,1],"nesting":[10,7,7,4,8,2,9,2,15,2,4,1,5,1],"overlapping":[10,7,7,4,8,2,9,2,4,1,5,1],"line":[5,7,4,1,7,1,8,1,14,1],"code":[7,9,14,8,15,2,4,1,5,1,6,1,10,1,12,1,16,1,17,1],"examples":[4,1,5,1,6,1,10,1,16,1,17,1],"callbacks":[4,1,15,1,17,1],"types":[4,1,18,1],"regexpcreator":[14,18,7,5,13,5,4,3,18,2],"module":[18,2,4,1,13,1],"changes":[5,1,7,1,9,1],"behavior":[5,1,12,1],"dealing":[5,1],"dealt":[5,1],"correctly":[10,2,5,1],"handles":[5,1,15,1],"wrapallranges":[10,13,7,11,8,2,9,2,15,2,5,1,17,1],"useful":[5,1,7,1,11,1],"other":[5,1,19,1],"htlm":[5,1],"minified":[5,1],"formatting":[5,1],"play":[5,1,16,1],"playground":[5,1,16,1],"minimal":[5,1],"range":[7,62,8,22,5,2,10,2],"scroll":[5,1],"view":[5,1],"classname":[7,6,10,4,6,2,8,2,9,2,15,2,19,2,5,1,17,1],"scrollintoview":[5,1],"syntax":[6,1,8,1,9,1,19,1],"search":[7,15,14,10,6,6,9,1,11,1,19,1],"parameters":[19,2,6,1,7,1,8,1,9,1],"strings":[7,7,6,2,12,2,9,1,14,1],"description":[6,1,8,1,9,1,19,1],"span":[6,1,8,1,9,1,19,1],"specifies":[6,2,19,2,8,1,9,1],"excluded":[7,5,6,1,8,1,9,1,19,1],"searching":[14,7,11,6,6,4,7,1,8,1,9,1,19,1],"break":[7,10,6,1,16,1],"individual":[6,3,7,2,11,2,13,1,14,1,15,1],"word":[11,7,10,4,6,3,7,3,14,2],"preserveterms":[7,2,6,1,11,1],"preserved":[6,1,11,1],"surrounding":[6,1,7,1,11,1],"double":[6,1,7,1,11,1],"quotes":[7,2,11,2,6,1],"breaking":[6,1,11,1],"diacritics":[14,8,12,3,6,2,13,1],"diacritic":[14,2,6,1,13,1],"characters":[14,16,6,6,11,2],"casesensitive":[14,5,6,2,13,2,7,1],"sensitive":[6,1,14,1],"accuracy":[14,16,6,3,13,3,11,2],"partially":[14,4,6,3,11,1],"one":[6,6,7,5,14,5,15,5,13,1,19,1],"following":[14,2,6,1,18,1],"back":[6,2],"visa":[6,2],"exactly":[14,5,13,4,6,3,11,3],"actually":[6,1],"forced":[6,1],"white":[6,4,11,2,8,1],"startswith":[6,3,14,3,11,2,13,2],"prefix":[6,1],"predict":[6,1],"prefab":[6,1],"complementary":[14,4,6,3,11,2],"built":[11,7,7,2,6,1],"_":[14,2,6,1,11,1],"limiters":[14,11,13,3,6,2,11,2],"disabled":[14,6,6,3],"as":[14,6,10,4,15,4,6,3,13,3,7,2,17,2,12,1,16,1],"unless":[6,1],"they":[7,3,15,2,6,1,10,1],"escaped":[6,1,7,1],"enabled":[14,3,6,1,7,1],"non":[14,9,6,3,13,3,8,1],"space":[14,8,7,5,6,3,11,2],"zero":[14,14,6,7,7,3],"time":[6,3,8,1,9,1,12,1,19,1],"times":[6,3,12,1],"but":[7,2,6,1,10,1,11,1,12,1,15,1,16,1,19,1],"few":[6,1],"possible":[6,1,15,1,17,1,19,1],"ignorejoiners":[14,4,6,2,13,1],"find":[15,2,6,1,7,1,10,1,17,1],"contain":[6,1,14,1],"soft":[14,4,6,1],"hyphen":[6,1,14,1],"width":[14,8,6,3],"joiner":[6,2,14,2],"ignorepunctuation":[14,7,6,2,13,1],"punctuation":[14,6,6,1],"synonyms":[14,5,6,3,13,1],"synonym":[6,1,14,1],"vice":[6,1],"versa":[6,1],"am":[6,1],"combinepatterns":[12,7,6,3,7,2],"combine":[13,2,6,1,7,1,12,1,14,1],"patterns":[7,5,12,4,14,4,6,1],"cachetextnodes":[7,9,12,3,6,2],"caching":[6,1,12,1],"improve":[6,1,12,1],"limit":[6,1,9,1,11,1],"extends":[6,1,7,1,9,1],"otherwise":[6,1,9,1,10,1],"do":[6,1,9,1,15,1],"ms":[12,29,10,4,6,1,7,1,8,1,9,1,19,1],"max":[7,7,6,1,8,1,9,1,19,1],"wait":[6,1,7,1,8,1,9,1,19,1],"before":[7,11,14,2,6,1,8,1,9,1,19,1],"skipping":[6,1,7,1,8,1,9,1,19,1],"messages":[6,2,7,2,8,2,9,2,19,2],"specific":[6,1,8,1,9,1,19,1],"located":[6,1,7,1,8,1,9,1,17,1],"several":[7,2,6,1,8,1,9,1,11,1,15,1],"part":[7,8,6,2,8,2,9,2],"filterinfo":[7,21,6,4,9,4],"includes":[7,4,6,1,8,1,9,1,14,1],"current":[7,34,17,4,8,3,9,3,10,3,6,2,15,2],"wrapped":[7,22,10,7,6,3,9,2,8,1,13,1],"so":[7,7,6,4,9,3,15,2,8,1,12,1],"far":[7,5,6,4,9,3,8,1,15,1],"result":[7,7,14,4,6,2,9,2],"exec":[7,13,6,2,9,2],"ae":[11,8,9,5,6,3],"helper":[6,1,7,1,9,1],"early":[6,1,7,1,9,1],"setting":[14,6,6,1,7,1,9,1],"breaks":[7,2,6,1,9,1,14,1],"offset":[7,25,6,2,9,2],"absolute":[7,2,6,1,9,1],"index":[7,97,8,4,9,3,15,3,6,1],"joined":[6,1,7,1,9,1],"sum":[7,2,6,1,9,1],"lengths":[6,1,9,1],"separated":[7,2,6,1,9,1,11,1],"composite":[7,17,6,1,9,1],"must":[7,4,9,3,19,3,6,2,8,2,14,1],"wrap":[7,4,15,2,6,1,8,1,9,1,10,1,14,1],"wrapping":[7,18,6,1,8,1,9,1,10,1,15,1],"marked":[7,18,19,6,10,4,6,3,8,3,9,3,12,3,14,3,15,2,11,1],"eachinfo":[7,12,6,4,9,4],"finish":[6,1,8,1,9,1],"totalmarks":[7,13,6,3,8,3,9,3,17,3,10,1],"totalmatches":[7,12,17,5,6,3,9,3,10,2,8,1],"termstats":[7,17,17,6,6,3],"total":[6,2,7,2,8,2,9,2,17,2],"nomatch":[7,9,6,3,8,3,9,3],"at":[7,5,6,1,14,1,16,1],"found":[17,5,7,2,6,1],"parameter":[13,2,6,1,14,1],"available":[7,5,9,5,6,3,14,2],"depending":[6,2,7,2,9,2,14,2,15,1],"markssofar":[6,1],"termmarkssofar":[6,1],"set":[7,5,9,3,11,2,13,2,14,2,6,1],"marks":[7,5,10,4,17,4,14,2],"gmi":[7,1],"nodenames":[7,2],"title":[7,1],"head":[7,1],"commonoptions":[7,5],"property":[7,75,14,15,10,1],"exclusion":[7,1],"those":[7,1,14,1],"will":[14,10,7,5,11,3],"ignored":[10,3,14,2,7,1,9,1],"maximum":[7,1],"markeachcallback":[7,2],"marknomatchcallback":[7,2],"commondonecallback":[7,2],"defined":[14,2,7,1],"user":[7,3],"initialized":[7,1],"val":[7,8,14,8],"merged":[7,1],"defaults":[7,1],"throw":[7,1],"please":[7,1],"provide":[7,1],"win":[7,5],"_opt":[7,4],"assign":[7,1,14,1],"ignoregroups":[7,14,9,7],"shortens":[7,1],"lengthy":[7,1],"simplify":[7,1],"createtextnode":[7,1],"always":[7,1],"logs":[7,15],"message":[7,4],"msg":[7,3],"level":[7,13,10,1],"warn":[7,2],"logobject":[7,3],"errors":[7,1],"objects":[7,11,8,1,10,1],"report":[7,4],"item":[7,6,14,4,12,2],"json":[7,2],"stringify":[7,2,8,1,9,1],"validity":[7,1],"cache":[7,6,12,1],"relation":[7,1],"checkoption":[7,5],"del":[7,2],"dict":[7,63],"cachedict":[7,11],"clear":[7,4],"doesn":[7,4,9,1,10,1,11,1],"change":[7,1,12,1],"splits":[7,9,11,1,14,1],"prevents":[7,6,12,1],"splitting":[7,1],"entries":[7,2,14,1],"descending":[7,2],"initializes":[7,2],"sv":[7,8],"getseachterms":[7,2],"split":[7,7,14,4],"str":[14,56,7,33],"quoted":[7,1,11,1],"matter":[7,1,11,1],"many":[7,1,11,1],"side":[11,2,7,1],"i":[7,49,14,28,17,3,11,2,10,1],"numeric":[7,3],"allowed":[7,1],"isnumeric":[7,3],"eslint":[7,1],"disable":[7,1,14,1],"next":[7,13,17,3,10,2],"eqeqeq":[7,1],"parsefloat":[7,1],"valid":[7,3,8,1],"setofranges":[7,5],"unprocessed":[7,1],"raw":[7,1],"processed":[7,5],"invalid":[7,3],"removed":[7,1,19,1],"checkranges":[7,2],"parseint":[7,3],"nest":[7,1],"overlapp":[7,1],"ing":[7,1],"blockelementsboundaryobject":[7,1],"separating":[7,1],"sets":[7,5,17,1],"tags":[7,14],"settype":[7,2],"normalizes":[7,4],"key":[14,9,7,2],"nodeinfoacross":[7,5],"correct":[7,2,15,1],"was":[7,2],"after":[7,3,14,1,19,1],"startoffset":[7,13],"offsets":[7,2],"negative":[7,1],"gettextnodesacrossdict":[7,3],"store":[7,5],"last":[7,11,11,3],"lasttextindex":[7,7],"gettextnodesacrosscallback":[7,2],"positions":[7,3],"cb":[7,8],"gettextnodesacross":[7,3],"uses":[7,2,10,2,14,1,19,1],"reset":[7,1],"indexes":[7,8,9,1,10,1],"safely":[7,1],"prioritytype":[7,2],"ch":[7,10,14,5],"temptype":[7,5],"prevnode":[7,11],"charat":[7,1],"regex":[7,44,9,10,10,7],"getnodeinfo":[7,3],"n":[7,33],"processes":[7,1],"createdict":[7,3],"previous":[7,8,10,2,17,2],"define":[7,1],"auxiliary":[15,3,7,1],"pass":[7,1],"startbyspace":[7,3],"both":[7,5,9,1,15,1],"searches":[7,1,11,1],"parent":[7,20,15,4],"met":[7,1],"condition":[7,1,15,1],"does":[12,2,15,2,7,1,14,1],"same":[13,3,7,2,12,2,14,1,15,1,17,1],"createinfo":[7,4],"nodeinfo":[7,10],"required":[7,3,15,1],"compatibility":[7,3,9,1,15,1],"gettextnodesdict":[7,2],"gettextnodescallback":[7,2],"gettextnodes":[7,4],"newlines":[7,9],"show":[7,2],"len":[7,6],"rm":[7,8],"tagname":[7,1],"faster":[7,1],"three":[7,3,13,3],"wraps":[7,15,10,1],"related":[12,2,7,1,15,1],"newly":[7,1],"created":[7,3,14,1,16,1],"inserts":[7,2,16,1],"replace":[14,12,7,1],"existing":[7,1,12,1],"create":[13,6,7,4,14,4,10,1,12,1],"sibling":[7,4],"splittext":[7,6],"wraprangeinsertdict":[7,1],"dictionary":[7,5],"currently":[7,1,15,1],"splitted":[7,1],"appear":[7,1],"increment":[7,5],"wraprangeinsert":[7,4],"ended":[7,6],"splitindex":[7,3],"creating":[7,1],"retnode":[7,5],"wraptextnode":[7,3],"markchild":[7,3],"childnodes":[7,2],"splice":[7,3],"wraprangeeachcallback":[7,1],"wraprange":[7,6],"attributes":[7,1],"around":[7,3,14,1],"marknode":[7,6],"replacechild":[7,4],"wraprangeacrossdict":[7,2],"wraprangeacrosseachcallback":[7,2],"rangestart":[7,8],"wraprangeacrossfiltercallback":[7,2],"determines":[7,1],"wraprangeacross":[7,5],"stores":[7,1],"avoid":[7,5],"iteration":[7,1],"beginning":[7,5,16,1],"enable":[7,1,14,1],"here":[7,1],"finds":[7,1],"starting":[7,1,12,1],"occurs":[7,11],"separategroups":[9,9,7,8,10,4,15,3],"group":[7,78,15,25,9,7,10,6,14,5,13,4],"assertion":[7,3,13,2,15,2,14,1],"exception":[7,1],"debugging":[7,1],"purpose":[7,1],"subsequent":[7,1],"paramsobject":[7,5],"expression":[7,10,14,8,9,1],"searched":[7,9],"wrapgroupsfiltercallback":[7,2],"wrapgroupseachcallback":[7,2],"params":[7,18],"wrapgroups":[7,2],"startindex":[7,8],"iswrapped":[7,10],"way":[7,3,10,1,15,1],"being":[7,2],"parse":[7,2],"pattern":[14,15,13,12,7,9,12,6],"collect":[7,2],"resets":[7,4],"infinite":[7,3],"wrapgroupsacrossfiltercallback":[7,2],"wrapgroupsacrosseachcallback":[7,2],"groupstart":[7,10,9,2,15,1],"wrapgroupsacrossdict":[7,1],"wrapgroupsacross":[7,2],"approach":[7,1],"reliable":[7,1,8,1,15,1],"adjacent":[7,1,9,1],"unwanted":[7,1,10,1,15,1],"easily":[7,1,13,1,15,1],"wrapgroupsdflagfiltercallback":[7,1],"wrapgroupsdflageachcallback":[7,2],"hasindices":[7,12],"wrapgroupsdflagcallback":[7,1],"wrapgroupsdflag":[7,2],"indices":[7,4,15,1],"subtract":[7,1],"least":[7,1],"we":[7,2],"need":[7,3,11,2,15,2,18,2,10,1],"control":[7,2,9,1],"setlastindex":[7,3],"wrapgroupsdflagacrossfiltercallback":[7,2],"wrapgroupsdflagacrosseachcallback":[7,2],"wrapgroupsdflagacrossdict":[7,1],"wrapgroupsdflagacross":[7,2],"processing":[7,1],"conditions":[7,1],"positive":[7,2,10,1,14,1],"lookahead":[14,6,13,4,7,2,15,1],"lookbehind":[14,8,13,4,7,3,15,1],"parses":[7,1],"collects":[7,1],"children":[7,1],"collectgroupindexes":[7,3],"stack":[7,4],"brackets":[7,3],"source":[7,2],"rest":[7,1],"parentheses":[7,1],"close":[7,2],"parenthesis":[7,3],"pop":[7,1],"filterinfoobject":[7,7],"groupindex":[15,7,7,6,9,4,10,3],"translate":[7,1],"local":[7,1],"eachinfoobject":[7,7],"wrapseparategroupsfiltercallback":[7,2],"wrapseparategroupseachcallback":[7,2],"wrapseparategroupsendcallback":[7,2],"unused":[7,4],"endcb":[7,15],"wrapseparategroups":[7,2],"filterstart":[7,8],"eachstart":[7,10],"grindex":[7,8],"wrapseparategroupsacrossfiltercallback":[7,2],"wrapseparategroupsacrosseachcallback":[7,2],"wrapseparategroupsacrossendcallback":[7,2],"wrapseparategroupsacross":[7,2],"wrapmatchesfiltercallback":[7,2],"wrapmatcheseachcallback":[7,2],"wrapmatchesendcallback":[7,2],"wrapmatches":[7,4],"k":[7,6,14,2],"continue":[7,1],"calculates":[7,2],"corrects":[7,1],"inserted":[7,1,10,1],"flag":[9,5,10,5,7,4,15,3],"resetting":[7,1],"wrapmatchesacrossfiltercallback":[7,2],"wrapmatchesacrosseachcallback":[7,2],"wrapmatchesacrossendcallback":[7,2],"wrapmatchesacross":[7,4],"mstart":[7,3],"wraprangeseachcallback":[7,2],"rangeobject":[7,7],"modified":[7,3],"integers":[7,1],"rangeinfoobject":[7,3],"rangeinfo":[7,3,8,3],"wraprangesfiltercallback":[7,2],"substr":[7,4],"extracted":[7,1],"wraprangesendcallback":[7,2],"indicated":[7,1],"wrapranges":[7,2],"skipped":[7,3,8,1],"substring":[7,1],"whitespace":[7,3,14,2],"even":[7,1],"visible":[7,1],"unwraps":[7,2],"destroying":[7,1],"possibly":[7,1],"present":[7,1],"events":[7,1],"innerhtml":[7,1],"unwrap":[7,1],"unwrapmatches":[7,2],"most":[7,3,11,1],"common":[7,4,14,1],"child":[11,3,7,1,10,1,15,1,16,1],"previoussibling":[7,1],"nextsibling":[7,1],"nodevalue":[7,8],"likely":[7,2],"docfrag":[7,3],"createdocumentfragment":[7,1],"appendchild":[7,1],"normalize":[7,1],"markregexpfiltercallback":[7,2],"markregexpeachcallback":[7,2],"markregexpnomatchcallback":[7,2],"markregexpoptions":[7,2],"solves":[7,1],"backward":[7,1,9,1],"issue":[7,1],"gate":[7,1],"slip":[7,1],"global":[7,1],"sticky":[7,1],"tostring":[7,1],"recompiled":[7,1],"markfiltercallback":[7,2],"termmatches":[7,10],"finished":[7,1],"counts":[7,1],"markoptions":[7,2],"markcombinepatterns":[7,2],"regcreator":[7,2],"collecting":[7,1,12,1],"statistics":[7,1],"flags":[14,5,7,2,9,1],"getpatterns":[7,2],"regterms":[7,4],"getcurrentterm":[7,2],"matched":[7,1,14,1],"better":[7,1,12,1],"their":[7,2],"shorter":[7,1],"appears":[7,1],"frequently":[7,1],"minus":[7,1,14,1],"chunks":[7,2],"combines":[7,1,12,1],"chunk":[7,2],"combined":[12,2,7,1],"creator":[13,6,7,2],"num":[7,6],"math":[7,3],"pow":[7,1],"isinteger":[7,1],"ceil":[7,1],"slice":[7,4,14,1],"createcombinepattern":[13,4,7,1,14,1],"markrangesoptions":[7,2],"markrangeseachcallback":[7,2],"markrangesnomatchcallback":[7,2],"markrangesfiltercallback":[7,2],"bounds":[7,1],"overlaps":[7,1],"another":[7,1,10,1],"original":[7,1],"totalranges":[7,2,8,2],"removal":[7,1],"integer":[8,1],"texts":[8,1],"matchingstring":[8,1],"works":[9,1],"y":[9,1],"allow":[14,2,15,2,9,1],"recompile":[9,1],"although":[9,1],"require":[9,1,10,1],"still":[9,1,11,1,14,1],"recommended":[9,1],"having":[9,1,10,1,17,1],"future":[9,1],"w":[10,7,9,3,14,1],"sg":[9,5],"above":[9,2,12,1,13,1],"lookaround":[10,3],"assertions":[10,2],"practically":[10,1,11,1],"restrictions":[10,1],"demonstrate":[10,1],"cases":[14,2,10,1,11,1,15,1],"won":[10,1,15,1],"highlighted":[12,2,10,1,11,1],"dg":[10,4],"second":[12,3,10,1,13,1,14,1],"overlap":[10,1],"cause":[10,1],"degradation":[10,1],"very":[10,1],"large":[12,2,10,1],"lot":[10,1],"copying":[10,1],"memory":[10,1],"allocation":[10,1],"file":[10,2],"sec":[10,4,12,4],"regardless":[10,1],"been":[10,1,15,1],"distinguish":[10,1],"treats":[10,1],"simple":[10,1,17,1],"buttons":[10,2,17,2],"numbers":[10,1,12,1],"unique":[10,1,17,1],"identifiers":[10,1],"continuous":[10,1],"ascending":[10,1],"work":[10,1],"currentindex":[17,7,10,6],"matchcount":[17,7,10,4],"sentences":[10,1],"dgi":[10,1],"identifier":[10,1,17,1],"prevbutton":[10,1,17,1],"click":[10,2,17,2],"highlightmatchgroups":[10,3],"nextbutton":[10,1,17,1],"removeclass":[10,1],"elems":[10,2],"addclass":[10,2,17,2],"descendant":[10,1,17,1],"under":[11,1],"development":[11,1],"aggregate":[11,1],"taking":[11,1],"account":[11,1],"textcontents":[11,1],"headerparagraph":[11,1],"due":[11,1],"undesirable":[11,1],"applies":[11,1],"exact":[15,3,11,1,14,1],"alone":[11,1],"searchings":[11,1],"keep":[11,1],"intact":[11,1],"middle":[11,1],"shouldn":[11,1],"pretty":[11,1],"handy":[11,1],"descendants":[11,1],"specify":[11,1,18,1],"perform":[11,1],"aggregated":[11,1],"anything":[11,1],"continued":[11,2],"til":[11,2],"satisfactory":[11,1],"inline":[11,1,16,1],"results":[12,1],"firefox":[12,4],"compare":[12,1,15,1],"size":[12,13],"chrome":[12,2],"ways":[12,1],"boost":[12,2],"especially":[12,1],"items":[12,3],"run":[12,2,19,1],"efficient":[12,1],"given":[12,1],"runs":[12,2],"bigger":[12,1],"monstrous":[12,1],"slowly":[12,1],"probably":[12,1],"processor":[12,1],"expensive":[12,1],"improves":[12,1],"gain":[12,1],"gradually":[12,1],"grows":[12,1],"doubled":[12,1],"mb":[12,1],"creatediacritics":[13,4,14,2],"actuality":[13,1],"converted":[13,1],"replacing":[13,1],"real":[13,1],"capture":[14,3,13,2],"accepted":[13,1],"affected":[13,1],"based":[14,2],"settings":[14,3],"gm":[14,1],"accuracyobj":[14,2],"lor":[14,10],"nothing":[14,1],"wildcard":[14,6],"m":[14,14],"lorm":[14,3],"loram":[14,3],"etc":[14,4],"lore":[14,1],"et":[14,1],"would":[14,2],"worlds":[14,1],"world":[14,1],"wo":[14,1],"rlds":[14,1],"apostrophes":[14,1],"letters":[14,1],"produce":[14,1],"o":[14,1],"r":[14,1],"l":[14,1],"typical":[14,1],"could":[14,1],"follows":[14,1],"well":[14,2],"dash":[14,4],"em":[14,1],"wikipedia":[14,2],"wiki":[14,2],"figure_dash":[14,1],"ref":[14,1],"underscore":[14,1],"joiners":[14,10],"hyphens":[14,3],"patternobj":[14,4],"lower":[14,2],"upper":[14,2],"chars":[14,4],"_chars":[14,4],"initialises":[14,1],"aàáảãạăằắẳẵặâầấẩẫậäåāą":[14,1],"cçćč":[14,1],"dđď":[14,1],"eèéẻẽẹêềếểễệëěēę":[14,1],"iìíỉĩịîïī":[14,1],"lł":[14,1],"nñňń":[14,1],"oòóỏõọôồốổỗộơởỡớờợöøōő":[14,1],"rř":[14,1],"sšśșş":[14,1],"tťțţ":[14,1],"uùúủũụưừứửữựûüůūű":[14,1],"yýỳỷỹỵÿ":[14,1],"zžżź":[14,1],"touppercase":[14,1],"considering":[14,2],"parts":[14,1],"checkwildcardsescape":[14,3],"createsynonyms":[14,2],"getjoinerspunctuation":[14,2],"setupignorejoiners":[14,2],"createjoiners":[14,2],"createwildcards":[14,2],"createaccuracy":[14,2],"distinct":[14,4],"join":[14,6],"longest":[14,1],"entry":[14,1],"shortest":[14,1],"arry":[14,3],"sortbylength":[14,2],"z":[14,1],"escapes":[14,2],"special":[14,3],"escape":[14,5],"preprocess":[14,3],"syn":[14,7],"keys":[14,1],"hasownproperty":[14,1],"unshift":[14,1],"placeholders":[14,4],"later":[14,2],"insertion":[14,2],"replaces":[14,3],"gr":[14,2],"backslash":[14,1],"latter":[14,1],"anychar":[14,2],"designated":[14,2],"grouping":[14,2],"construct":[14,2],"placeholder":[14,1],"continues":[14,1],"pairs":[14,2],"backslashes":[14,1],"surrogate":[14,1],"udbff":[14,1],"udfff":[14,1],"punct":[14,3],"u":[14,4],"lowercase":[14,3],"serves":[14,1],"contained":[14,1],"actual":[14,1],"chs":[14,3],"important":[15,1,19,1],"branches":[15,1],"existence":[15,1],"primitive":[15,4],"base":[15,1],"contiguous":[15,1],"browsers":[15,1],"supported":[15,1],"identical":[15,1],"logic":[15,2],"means":[15,1,17,1],"don":[15,1],"care":[15,1],"branch":[15,1],"strict":[15,1],"requirement":[15,1],"contiguity":[15,1],"aab":[15,1],"xxx":[15,1],"bcd":[15,1],"xx":[15,1],"bc":[15,8],"warning":[15,1],"such":[15,1],"cd":[15,3,17,2],"ef":[17,2,15,1],"lays":[15,1],"presence":[15,1],"named":[15,1],"groupcount":[15,2],"trueallows":[16,1],"your":[16,1],"operation":[16,1],"invasive":[16,1],"alternative":[16,1],"documentfragment":[16,1],"getrootnode":[16,1],"document_fragment_node":[16,1],"color":[16,1],"red":[16,1],"external":[17,2],"internal":[17,2],"unusable":[17,1],"startelements":[17,6],"hasclass":[17,2],"eq":[17,2],"highlightmatch":[17,3],"el":[17,6],"folder":[18,1],"ts":[18,7],"imported":[18,2],"others":[18,1],"full":[18,1],"environment":[18,1],"safe":[19,1],"apply":[19,1]};
