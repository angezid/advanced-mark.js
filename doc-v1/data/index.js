var Pages = [["elements-boundaries","Elements boundaries"],["filtering-matches","Filtering matches"],["index","Content"],["mark-method","mark() method"],["markRanges-method","markRanges() method"],["markRegExp-method","markRegExp() method"],["nesting-overlapping","Nesting/overlapping ranges and match groups"],["performance","Performance"],["RegExpCreator-module","RegExpCreator module"],["separate-groups","Highlighting separate groups"],["shadow-dom","Highlighting in shadow DOM"],["some-examples","Code examples"],["unmark-method","unmark() method"]];
var Headers = {"0":[["Elements boundaries","5","elements-boundaries"],["Header","6","1111"],["Extending default block elements with custom elements:","4","extending-default-block-elements-with-custom-elements"]],"1":[["Filtering matches","5","filtering-matches"],["To filter matches in the mark() method with acrossElements option","3","to-filter-matches-in-the-mark-method-with-acrosselements-option"],["To filter matches in the mark() method without acrossElements option","3","to-filter-matches-in-the-mark-method-without-acrosselements-option"],["To filter matches in the markRegExp() method","3","to-filter-matches-in-the-markregexp-method"],["Mark the first desired number of matches on each callback using acrossElements option.","3","mark-the-first-desired-number-of-matches-on-each-callback-using-acrosselements-option"]],"2":[["Content","5","1112"]],"3":[["mark() method","5","mark-method"],["Syntax","4","syntax"],["Parameters:","3","parameters"],["Available properties of the filterInfo object depending on options","4","available-properties-of-the-filterinfo-object-depending-on-options"],["Available properties of the eachInfo object depending on options","4","available-properties-of-the-eachinfo-object-depending-on-options"]],"4":[["markRanges() method","5","markranges-method"],["Syntax","4","syntax"],["Parameters:","3","parameters"]],"5":[["markRegExp() method","5","markregexp-method"],["Syntax","4","syntax"],["Parameters:","3","parameters"],["Available properties of the filterInfo object depending on options","4","available-properties-of-the-filterinfo-object-depending-on-options"],["Available properties of the eachInfo object depending on options","4","available-properties-of-the-eachinfo-object-depending-on-options"]],"6":[["Nesting/overlapping ranges and match groups","5","nestingoverlapping-ranges-and-match-groups"],["To mark nesting/overlapping ranges.","3","to-mark-nestingoverlapping-ranges"],["To mark nesting groups with acrossElements option and d flag.","3","to-mark-nesting-groups-with-acrosselements-option-and-d-flag"],["To mark nesting groups without d flag.","3","to-mark-nesting-groups-without-d-flag"],["To mark nesting/overlapping groups without acrossElements option and with RegExp having the d flag.","3","to-mark-nestingoverlapping-groups-without-acrosselements-option-and-with-regexp-having-the-d-flag"],["Simple example with next/previous buttons.","3","simple-example-with-nextprevious-buttons"]],"7":[["Performance","5","performance"],["The performance results in Firefox compare to mark.js v8.11.1:","4","the-performance-results-in-firefox-compare-to-mark.js-v8.11.1"],["Ways to boost performance","4","ways-to-boost-performance"]],"8":[["RegExpCreator module","5","regexpcreator-module"]],"9":[["Highlighting separate groups","5","highlighting-separate-groups"],["Filtering capturing groups:","3","filtering-capturing-groups"],["Example to mark separate groups with acrossElements option:","3","example-to-mark-separate-groups-with-acrosselements-option"],["Example to mark separate groups without acrossElements option:","3","example-to-mark-separate-groups-without-acrosselements-option"]],"10":[["Highlighting in shadow DOM","5","highlighting-in-shadow-dom"]],"11":[["Code examples","5","code-examples"],["The mark() method code example with acrossElements option","3","the-mark-method-code-example-with-acrosselements-option"],["The mark() method code example without acrossElements option","3","the-mark-method-code-example-without-acrosselements-option"],["The markRegExp() method code example with acrossElements option","3","the-markregexp-method-code-example-with-acrosselements-option"],["Simple example with next/previous buttons.","3","simple-example-with-nextprevious-buttons"]],"12":[["unmark() method","5","unmark-method"],["Syntax","4","syntax"],["Parameters:","3","parameters"]]};
var Common = {"a":1,"also":1,"an":1,"and":1,"are":1,"as":1,"at":1,"be":1,"by":1,"can":1,"for":1,"from":1,"get":1,"if":1,"in":1,"is":1,"it":1,"none":1,"not":1,"of":1,"on":1,"only":1,"or":1,"see":1,"set":1,"that":1,"the":1,"this":1,"to":1,"use":1,"used":1,"when":1,"will":1,"with":1,"you":1};
var Info = [["Elements boundaries∎With acrossElements option, advance-mark.js aggregates text nodes content into a single string, taking into account HTML elements. If a block element 'divides' two text nodes, and node.textContents doesn't separated by white space, the space is added to the string to separate them, e.g. '∎Header∎Paragraph∎' resulted: in mark.js - 'HeaderParagraph', in advance-mark.js - 'Header Paragraph'. But the acrossElements option doesn't 'knows' any boundaries. A blockElementsBoundary option is 'invented' to limit matches within HTML block elements. It allows matches only across HTML inline elements (blockElementsBoundary : true).∎With the blockElementsBoundary option, if a block element 'divides' two text nodes, \\x01 character with spaces (it depend) is added between them, e.g. above combined string becomes 'Header \\x01 Paragraph'. If the custom tagNames are defined:∎they can be the only elements that have boundaries∎they can be added to the default block elements∎The blockElementsBoundary option makes sense only when highlighting phrases or RegExp separate groups, or using a wildcards character * with wildcards : 'withSpaces' option.∎blockElementsBoundary {boolean|object} - Option: (default is undefined)∎tagNames {string[]} - The string or array of tag name. (default is undefined)∎extend - Whether to extend the default block elements with custom elements or only specify custom elements have boundaries. (default is false)∎char - The custom boundary char. (default is \\x01)∎instance.mark('lorem ipsum dolor', { 'separateWordSearch' : false, 'acrossElements' : true, 'blockElementsBoundary' : true, // or 'blockElementsBoundary' : { // only these custom elements have boundaries 'tagNames' : ['div', 'p', 'h1', 'h2'], // optional // custom boundary char, default is '\\x01' 'char' : '.' // optional } });∎Extending default block elements with custom elements:∎context.markRegExp(/.../gi, { 'acrossElements' : true, 'blockElementsBoundary' : { // custom elements are added to the default block elements 'tagNames' : ['tab-container', 'custom-tag'], 'extend' : true } });∎The default elements are:∎address, area, article, aside, audio, blockquote, body, br, button, canvas, dd, details, div, dl, dt, fieldset, figcaption, figure, footer, form, h1, h2, h3, h4, h5, h6, header, hr, iframe, img, input, label, li, main, map, menu, menuitem, meter, nav, object, ol, output, p, picture, pre, section, select, svg, table, tbody, td, textarea, tfoot, th, thead, tr, track, ul, video",0],
["Filtering matches∎See mark() filter callback and markRegExp() filter callback about filter callback info object properties. To filter RegExp capturing groups see: Filtering capturing groups.∎To filter matches in the mark() method with acrossElements option∎let count = 0; instance.mark('AB', { 'acrossElements' : true, 'filter' : (textNode, term, marksSoFar, termMarksSoFar, info) =&gt; { // to mark only the first match info.execution.abort = true; return true; // filter callback requires its own match counter if (info.matchStart) { count++; } // mark the first 10 matches. if (count &gt; 10) { info.execution.abort = true; return false; } // skip between if (count &gt; 10 &amp;&amp; count &lt; 20) { return false; } // mark between if (count &lt;= 10) { return false; } else if (count &gt; 20) { info.execution.abort = true; return false; } return true; } });∎To filter matches in the mark() method without acrossElements option∎let count = 0; instance.mark('AB', { 'filter' : (textNode, term, marksSoFar, termMarksSoFar, info) =&gt; { // the only difference is counter implementation count++; } });∎To filter matches in the markRegExp() method∎let count = 0, reg = /.../gi; // if you have access to the RegExp object with 'acrossElements' option, you can // also used `reg.lastIndex = Infinity;` instead of `info.execution.abort = true;` instance.markRegExp(reg, { 'filter' : (textNode, matchString, marksSoFar, info) =&gt; { // to mark only the first match info.execution.abort = true; return true; // filter callback requires its own match counter if (info.matchStart) { count++; } // mark the first 10 matches. if (count &gt; 10) { info.execution.abort = true; return false; } // skip between if (count &gt; 10 &amp;&amp; count &lt; 20) { return false; } // mark between if (count &lt;= 10) { return false; } else if (count &gt; 20) { info.execution.abort = true; return false; } return true; }, });∎Mark the first desired number of matches on each callback using acrossElements option.∎It's much more limited than the filter callback.∎let reg = /.../gi; instance.markRegExp(reg, { 'acrossElements' : true, 'each' : (markElement, info) =&gt; { // to mark only the first match reg.lastIndex = Infinity; // first 10 matches if (info.count &gt;= 10) { reg.lastIndex = Infinity; } } });",1],
["Content∎mark() method∎markRegExp() method∎markRanges() method∎unmark() method∎Filtering matches∎Highlighting separate groups∎Nesting/overlapping ranges and match groups∎Elements boundaries∎Highlighting in shadow DOM∎Code examples∎Performance∎RegExpCreator module",2],
["mark() method∎Syntax∎// javascript const instance = new Mark(context); instance.mark(search[, options]); // jQuery $(context).mark(search[, options]);∎Parameters:∎search string or string[] - string or array of strings∎options object - Optional options:∎Option∎Type∎Default∎Description∎element∎string∎mark∎A custom mark element e.g. span.∎className∎string∎''∎A class to be added to mark elements.∎exclude∎string or string[]∎[]∎A string or an array of selectors. Specifies DOM elements that should be excluded from searching.∎separateWordSearch∎boolean∎true∎Whether to break term into separate words and search for each individual word∎diacritics∎boolean∎true∎Whether to match diacritic characters∎caseSensitive∎boolean∎false∎Whether to search case sensitive∎accuracy∎string or object∎'partially'∎Either one of the following string value:∎'partially' e.g. searching 'a' mark 'a' in words 'and', 'back', and 'visa'.∎'exactly' This option is actually forced to use an accuracy object, because the default word boundaries are white-space characters and start/end of a text node (with acrossElements option - start/end of a context).∎'complementary' e.g. searching 'a' mark the whole words 'and', 'back', and 'visa'. The default word boundaries are: whitespaces and !&quot;#$%&amp;'`()*+,-./:;&lt;=&gt;?@[\\]^_{|}~¡¿ characters.∎Or an bject with two properties:∎value: 'exactly' or 'complementary'∎limiters: an array of custom word boundary characters, e.g. { value : &quot;exactly&quot;, limiters : &quot;,.;:?!'&quot;&quot;.split() }∎wildcards∎string∎disabled∎Two characters ? and * used as wildcards unless thay are escaped∎disabled: The characters ? and * match itself∎enabled:∎The character ? match any non-white-space character zero or one time.∎The character * match any non-white-space character zero or more times.∎withSpaces:∎The character ? match any character zero or one time.∎The character * match any character zero or more times, but as few times as possible.∎ignoreJoiners∎boolean∎false∎Whether to find matches that contain soft hyphen, zero width space, zero width non-joiner and zero width joiner∎ignorePunctuation∎string[]∎[]∎An array of punctuation characters∎synonyms∎object∎{}∎An object with synonyms∎e.g. { 'one': '1' } - '1' is synonym for 'one' and vice versa. Value can be an array { 'be': ['am', 'is', 'are'] }.∎acrossElements∎boolean∎false∎Whether to search for matches across elements∎combinePatterns∎number or boolean∎10∎Combine a specified number of individual term patterns into one∎See Performance for more details.∎cacheTextNodes∎boolean∎undefined∎Caching information to improve performance∎See Performance for more details.∎blockElementsBoundary∎boolean or object∎undefined∎Whether to limit matches within default HTML block elements and/or custom elements∎See Elements boundaries for more details.∎tagNames string[] - An array of custom HTML tag names∎extend boolean - true extends default boundary elements by the custom elements otherwise only the custom elements do have boundaries∎char string - A custom boundary character. The default is \\x01.∎shadowDOM∎boolean∎undefined∎Whether to mark inside shadow DOMs∎See Highlighting in shadow DOM for more details.∎iframes∎boolean∎false∎Whether to mark inside iframes∎iframesTimeout∎number∎5000 ms∎The max time to wait for iframe(s) to load before skipping∎debug∎boolean∎false∎Whether to log messages∎log∎object∎console∎Log messages to a specific object∎filter∎function∎A callback to filter matches. It calls for each match (with acrossElements option, if the match is located across several elements, it calls for each text node which is part of the match) filter : (textNode, term, marksSoFar, termMarksSoFar, filterInfo) =&gt; {}∎textNode Text - The text node which includes the match or with acrossElements option can be part of the match∎term string - The current term∎marksSoFar number - The number of all wrapped matches so far∎termMarksSoFar number - The number of wrapped matches for the current term so far∎filterInfo object:∎match array - The result of RegExp exec() method∎matchStart boolean - indicate the start of a match AE∎execution object - The helper object for early abort:∎abort boolean - Setting it to true breaks method execution∎offset number - When 'acrossElements: false': the absolute start index of a text node in joined context. When 'acrossElements: true': the sum of the lengths of separated spaces or boundary strings that were added to the composite string so far.∎each∎function∎A callback for each marked element each : (markElement, eachInfo) =&gt; {}∎markElement HTMLElement - The marked DOM element∎eachInfo object:∎match array - The result of RegExp exec() method∎matchStart boolean - Indicate the start of a match AE∎count number - The number of matches so far∎done∎function∎A callback on finish done : (totalMarks, totalMatches, termStats) =&gt; {}∎totalMarks number - The total number of marked elements∎totalMatches number - The total number of matches∎termStats object - An object containing an individual term's matches count∎noMatch∎function∎A callback that is called when a term has no match at all noMatch : (term) =&gt; {}∎term string or string[] - The not found term(s); the parameter is array when combinePatterns option is used∎Available properties of the filterInfo object depending on options∎options∎match∎matchStart∎execution∎offset∎acrossElements: true∎+∎+∎+∎+∎acrossElements: false∎+∎-∎+∎+∎Available properties of the eachInfo object depending on options∎options∎match∎matchStart∎count∎acrossElements: true∎+∎+∎+∎acrossElements: false∎+∎-∎+∎Example with default options values∎const options = { element : 'mark', className : '', separateWordSearch : true, diacritics : true, exclude : [], caseSensitive : false, accuracy : 'partially', synonyms : {}, ignoreJoiners : false, ignorePunctuation : [], wildcards : 'disabled', acrossElements : false, combinePatterns : false, cacheTextNodes : false, blockElementsBoundary : false, shadowDOM : false, iframes : false, iframesTimeout : 5000, filter : (textNode, term, marksSoFar, termMarksSoFar, filterInfo) =&gt; { return true; // must return either true or false }, each : (markElement, eachInfo) =&gt; {}, done : (totalMarks, totalMatches, termStats) =&gt; {}, noMatch : (term) =&gt; {}, debug : false, log : window.console };∎JavaScript:∎var instance = new Mark(document.querySelector('selector')); instance.mark('test', options);∎jQuery:∎$('selector').mark('test', options);∎AE - only available when acrossElements option is set to true",3],
["markRanges() method∎Syntax∎// javascript const instance = new Mark(context); instance.markRanges(ranges[, options]); // jQuery $(context).markRanges(ranges[, options]);∎Parameters:∎ranges object[] - An array of objects with start and length properties with integer type values.∎options object - Optional options:∎Option∎Type∎Default∎Description∎element∎string∎mark∎A custom mark element e.g. span.∎className∎string∎''∎A class to be added to mark elements.∎exclude∎string or string[]∎[]∎A string or an array of selectors. Specifies DOM elements that should be excluded from searching.∎wrapAllRanges∎boolean∎undefined∎Mark nesting/overlapping capturing groups∎See Marking nesting and overlapping ranges and match groups for more details.∎shadowDOM∎boolean∎undefined∎Whether to mark inside shadow DOMs∎See Highlighting in shadow DOM for more details.∎iframes∎boolean∎false∎Whether to mark inside iframes∎iframesTimeout∎number∎5000 ms∎The max time to wait for iframe(s) to load before skipping∎debug∎boolean∎false∎Whether to log messages∎log∎object∎console∎Log messages to a specific object∎filter∎function∎A callback to filter matches. It calls for each range (if a range is located across several elements, it calls for each text node which is part of the range) filter : (textNode, range, matchString, index) =&gt; {}∎textNode Text - The text node which includes the range or is the part of the range∎range object - The current range object∎matchString string - The current range matching string∎index number - The current range index ???∎each∎function∎A callback for each marked element each : (markElement, range, rangeInfo) =&gt; {}∎markElement HTMLElement - The marked DOM element∎range object - The range object∎rangeInfo object:∎matchStart boolean - indicate the start of a range;∎count number - The number of wrapped ranges so far∎done∎function∎A callback on finish done : (totalMarks, totalRanges) =&gt; {}∎totalMarks number - The total number of marked elements∎totalRanges number - The number of total ranges∎noMatch∎function∎A callback that is called on non-valid range noMatch : (range) =&gt; {}∎range string - The stringify range∎Example with default options values∎const options = { element : 'mark', className : '', exclude : [], wrapAllRanges : false, shadowDOM : false, iframes : false, iframesTimeout : 5000, filter : (textNode, range, matchingString, index) =&gt; { return true; // must return either true or false }, each : (markElement, range, rangeInfo) =&gt; {}, done : (totalMarks, totalMatches) =&gt; {}, noMatch : (range) =&gt; {}, debug : false, log : window.console };∎JavaScript:∎const instance = new Mark(document.querySelector('selector')), ranges = [{ start: 0, length: 5 }, { start: 6, length: 5 }]; instance.markRanges(ranges, options);∎jQuery:∎$('selector').markRanges(ranges, options);",4],
["markRegExp() method∎Syntax∎// javascript const instance = new Mark(context); instance.markRegExp(regex[, options]); // jQuery $(context).markRegExp(regex[, options]);∎Parameters:∎regex RegExp - The regular expression. With acrossElements option it must have g flag - it works with indexes and only two g and y flags allow control RegExp lastIndex. Note that for backward compatibility, RegExp without g flag is recompile internally with g flag. Although without acrossElements option it doesn't require g flag, it still recommended having this flag.∎options object - Optional options:∎Option∎Type∎Default∎Description∎element∎string∎mark∎A custom mark element e.g. span.∎className∎string∎''∎A class to be added to mark elements.∎exclude∎string or string[]∎[]∎A string or an array of selectors. Specifies DOM elements that should be excluded from searching.∎ignoreGroups∎number∎0∎The number of contiguous capturing groups that should be ignored from the start of RegExp∎e.g. /(\\w+)(.)(\\w+)(?!\\2)/g, ignoreGroups : 2 - mark the group 3∎separateGroups∎boolean∎false∎Whether to mark RegExp capturing groups instead of whole match∎See Highlighting separate groups for more details.∎acrossElements∎boolean∎false∎Whether to search for matches across elements∎wrapAllRanges∎boolean∎undefined∎Mark nesting/overlapping capturing groups∎See Marking nesting and overlapping ranges and match groups for more details.∎blockElementsBoundary∎boolean or object∎undefined∎Whether to limit matches within default HTML block elements and/or custom elements∎See Elements boundaries for more details.∎tagNames string[] - An array of custom HTML tag names∎extend boolean - true extends default boundary elements by the custom elements otherwise only the custom elements do have boundaries∎char string - A custom boundary character. The default is \\x01.∎shadowDOM∎boolean∎undefined∎Whether to mark inside shadow DOMs∎See Highlighting in shadow DOM for more details.∎iframes∎boolean∎false∎Whether to mark inside iframes∎iframesTimeout∎number∎5000 ms∎The max time to wait for iframe(s) to load before skipping∎debug∎boolean∎false∎Whether to log messages∎log∎object∎console∎Log messages to a specific object∎filter∎function∎A callback to filter matches. It calls for each match (with acrossElements option, if the match is located across several elements, it calls for each text node which is part of the match) filter : (textNode, matchString, marksSoFar, filterInfo) =&gt; {}∎textNode Text - The text node which includes the match or with acrossElements option can be part of the match∎matchString string - The matching string:∎without ignoreGroups and separateGroups options - the whole match∎with ignoreGroups option - the match[ignoreGroups+1] group matching string e.g. /(-)(\\w+)\\s+/g, ignoreGroups : 1, the matching string is content of the group 2∎with separateGroups option - the current group matching string∎marksSoFar number - The number of all wrapped matches so far∎filterInfo object:∎match array - The result of RegExp exec() method∎matchStart boolean - indicate the start of a match AE∎groupIndex number - The current group index SG∎execution object - The helper object for early abort:∎abort boolean - Setting it to true breaks method execution∎offset number - When 'acrossElements: false': the absolute start index of a text node in joined context. When 'acrossElements: true': the sum of the lengths of separated spaces or boundary strings that were added to the composite string so far.∎each∎function∎A callback for each marked element each : (markElement, eachInfo) =&gt; {}∎markElement HTMLElement - The marked DOM element∎eachInfo object:∎match array - The result of RegExp exec() method∎matchStart boolean - Indicate the start of a match AE∎count number - The number of matches so far∎groupIndex number - The current index of match group SG∎groupStart boolean - Indicate the start of group AE SG∎done∎function∎A callback on finish. done : (totalMarks, totalMatches) =&gt; {}∎totalMarks number - The total number of marked elements∎totalMatches number - The total number of matches∎noMatch∎function∎A callback that is called when regex failed to match noMatch : (regex) =&gt; {}∎regex string - The stringify RegExp∎Available properties of the filterInfo object depending on options∎options∎match∎matchStart∎groupIndex∎execution∎offset∎acrossElements∎+∎+∎-∎+∎+∎acrossElements, separateGroups∎+∎+∎+∎+∎+∎separateGroups∎+∎+∎+∎+∎+∎above options are false∎+∎-∎-∎+∎+∎Available properties of the eachInfo object depending on options∎options∎match∎matchStart∎groupIndex∎groupStart∎count∎acrossElements∎+∎+∎-∎-∎+∎acrossElements, separateGroups∎+∎+∎+∎+∎+∎separateGroups∎+∎+∎+∎-∎+∎above options are false∎+∎-∎-∎-∎+∎Example with default options values∎const options = { element : 'mark', className : '', exclude : [], ignoreGroups : 0, acrossElements : false, wrapAllRanges : false, blockElementsBoundary : false, shadowDOM : false, iframes : false, iframesTimeout : 5000, filter : (textNode, matchString, marksSoFar, filterInfo) =&gt; { return true; // must return either true or false }, each : (markElement, eachInfo) =&gt; {}, done : (totalMarks, totalMatches) =&gt; {}, noMatch : (regex) =&gt; {}, debug : false, log : window.console };∎JavaScript:∎const instance = new Mark(document.querySelector('selector')), regex = /../gi; instance.markRegExp(regex, options);∎jQuery:∎$('selector').markRegExp(regex, options);∎AE - only available when acrossElements option is set to true∎SG - only available when separateGroups option is set to true∎AE SG - only available when both acrossElements and separateGroups options are set to true",5],
["Nesting/overlapping ranges and match groups∎The markRanges() method with wrapAllRanges option, can mark nesting/overlapping ranges. With this option, all ranges that have indexes within 0 and context length be wrapped. The markRegExp() method with RegExp having the d flag, with separateGroups and wrapAllRanges options can mark: nesting groups, capturing groups inside positive lookaround assertions. It practically removes all restrictions. The lookaround examples demonstrate cases when wrapAllRanges option should be used, otherwise they won't be correctly highlighted:∎RegExp with lookaround assertions can create overlapping matches. e.g. regex /(?&lt;=(gr1)\\s+\\w+\\b).+?(gr2)/dg, string 'gr1 match1 gr1 gr2 match2 gr2'. The gr1 from the second match not wrapped because the gr2 from the first match is already wrapped.∎Another case: regex /(?=\\d*(1))(?=\\d*(2))(?=\\d*(3))/dg, matches '123, 132, 213, 231, 312, 321'. This is not an overlapping case, but groups are wrapped in any order. If group 1 is wrapped first, the 2 and 3 are ignored in '231, 321' ...∎Groups overlapping case: regex /\\w+(?=.*?(gr1 \\w+))(?=.*?(\\w+ gr2))/dg , string 'word gr1 overlap gr2' - the gr1 is wrapped, the gr2 is ignored.∎Note: the wrapAllRanges option can cause performance degradation if the context contains a very large number of text nodes and mark elements. This is because with each wrapping, two more objects are inserted into the array, which require a lot of copying, memory allocation ...∎The 8MB file containing 177000 text nodes:∎wrapAllRanges option∎marked groups 2500∎marked groups 29000∎true∎0.7 sec.∎2.9 sec.∎false∎0.65 sec.∎0.7 sec.∎The 1MB file containing 20800 text nodes:∎wrapAllRanges option∎marked groups 2500∎marked groups 29000∎true∎120 ms.∎710 ms.∎false∎70 ms.∎310 ms.∎Note: wrapAllRanges option with d flag wraps all capturing groups regardless of nested level. You need to filter out unwanted groups. Without this option - if a group has been wrapped, all nested groups are ignored.∎To mark nesting/overlapping ranges.∎const ranges = [{ start: 0, length: 50 }, { start: 10, length: 20, nested: true }, ..]; instance.markRanges(ranges, { 'wrapAllRanges' : true, 'each' : (markElement, range) =&gt; { // to distinguish ranges you can add some property to ranges if (range.nested) { markElement.className = 'nested'; } } });∎To mark nesting groups with acrossElements option and d flag.∎instance.markRegExp(/(\\w+\\s(nested group)\\s+\\w+)/dg, { 'acrossElements' : true, 'separateGroups' : true, 'wrapAllRanges' : true, 'each' : (markElement, info) =&gt; { if (info.groupStart) { // info.groupIndex is the index of a current match group if (info.groupIndex === 2) { markElement.className = 'nested'; } } } });∎To mark nesting groups without d flag.∎The whole match is highlighted as a main group and capturing group(s) as a nested group(s). It's the only way to mark nested groups without d flag.∎instance.markRegExp(/\\w+\\s(nested group)\\s+\\w+/g, { 'acrossElements' : true, 'separateGroups' : true, 'wrapAllRanges' : true, 'each' : (markElement, info) =&gt; { if (info.groupStart) { if (info.groupIndex === 1) { markElement.className = 'nested'; } } } });∎To mark nesting/overlapping groups without acrossElements option and with RegExp having the d flag.∎It's only possible through this hack:∎let regex = /.../dg; let ranges = buildRanges(instance, regex); instance.markRanges(ranges, { 'wrapAllRanges' : true, 'each' : (markElement, range) =&gt; { // handle the additional properties // markElement.setAttribute('data-markjs', range.id); } }); function buildRanges(instance, regex) { let ranges = []; // it should only build ranges - an attempt to mark any group can break regex normal workflow instance.markRegExp(regex, { 'separateGroups' : true, 'filter' : (textNode, group, marksSoFar, info) =&gt; { if (info.matchStart) { // 'i = 1' - skips match[0] group for (let i = 1; i &lt; info.match.length; i++) { if (info.match[i]) { let indices = info.match.indices[i]; // info.offset is added to translate the local group index to the absolute one let range = { start : info.offset + indices[0], length : indices[1] - indices[0] }; // some additional properties e.g. class/color to highlight nested group, // match identifer to highlight all match groups with next/previous buttons ... // can be added here to the range object ranges.push(range); } } } return false; } }); return ranges; }∎Simple example with next/previous buttons.∎It uses numbers as unique match identifiers in continuous ascending order. The code example with next/previous buttons which uses 'start elements' doesn't work correctly with nesting/overlapping matches.∎let currentIndex = 0, matchCount, marks, // highlight 3 words in sentences in any order, e.g. 'word word2 word word3 word word1.' regex = /(?=[^.]*?(word1))(?=[^.]*?(word2))(?=[^.]*?(word3))/dgi; instance.markRegExp(regex, { 'acrossElements' : true, 'separateGroups' : true, 'wrapAllRanges' : true, 'each' : (markElement, info) =&gt; { // info.count as a match identifier markElement.setAttribute('data-markjs', info.count); }, 'done' : (totalMarks, totalMatches) =&gt; { marks = $('mark'); matchCount = totalMatches; } }); prevButton.click(function() { if (--currentIndex &lt;= 0) currentIndex = 0; highlightMatchGroups(); }); nextButton.click(function() { if (++currentIndex &gt; matchCount) currentIndex = matchCount; highlightMatchGroups(); }); function highlightMatchGroups() { marks.removeClass('current'); const elems = marks.filter((i, elem) =&gt; $(elem).data('markjs') === currentIndex).addClass('current'); elems.find('*[data-markjs]').addClass('current'); // add class to all descendant too }",6],
["Performance∎The performance results in Firefox compare to mark.js v8.11.1:∎markRegExp() method, acrossElements : true; marked words 3000∎library∎size 100KB∎size 200KB∎size 500KB∎size 1MB∎mark.js∎~350 ms.∎~680 ms.∎~1700 ms.∎~2800 ms.∎this∎~30 ms.∎~35 ms.∎~45 ms.∎~60 ms.∎the same without acrossElements option; marked words 3000∎library∎size 100KB∎size 200KB∎size 500KB∎size 1MB∎mark.js∎~30 ms.∎~40 ms.∎~70 ms.∎~110 ms.∎this∎~30 ms.∎~35 ms.∎~40 ms.∎~50 ms.∎markRanges() method, marked ranges - 3000∎library∎size 100KB∎size 200KB∎size 500KB∎size 1MB∎mark.js∎~220 ms.∎~350 ms.∎~970 ms.∎~1700 ms.∎this∎~36 ms.∎~40 ms.∎~51 ms.∎~60 ms.∎Ways to boost performance∎Related highlighting a (especially) large array of strings or string with the separateWordSearch option. A mark() method highlights an array item by item, e.g. an array of 10 items is run 10 times. It isn't efficient.∎There are two options to boost performance :∎combinePatterns : combines given numbers of RegExp patterns into a single pattern, e.g. an array of 50 strings, combinePatterns : 10 - creates 5 combine patterns, so instead of 50 runs there are only 5 runs. Any number bigger than the array length or Infinity creates a single combined pattern. Note: with diacritics option, a single pattern can be monstrous and more slowly, it's better to create 5-7 patterns (it's probably related to a processor cache). Also, this option prevents highlighting inside already highlighted elements, but it only true for single combined pattern.∎cacheTextNodes : collecting text nodes information on every run is expensive. Caching this information improves performance with a large array. The performance gain gradually grows, starting with an array containing 2-3 items and doubled with 4-5 items. Note: this option does not change behavior as the combinePatterns option does. It can be used with existing code to improve performance.∎In Firefox marking an array of 500 words on a 1 MB page, 26500 text nodes, diacritics : false and ~7600 highlighted words :∎with combinePatterns : Infinity ~0.2 second. (single pattern)∎with cacheTextNodes option ~4.2 sec.∎with cacheTextNodes and acrossElements options ~1 sec.∎with acrossElements options ~21 sec.∎without above options ~19 sec.∎The same with diacritics:∎with combinePatterns : Infinity ~1.8 second. (single pattern)∎with combinePatterns : 100 ~0.4 second. (5 patterns)∎instance.mark([ 'str1', 'str2', .. ], { 'combinePatterns' : number // or true (default number is 10) });",7],
["RegExpCreator module∎It exposes three API - create(), createCombinePattern() and createDiacritics() methods. The create(string, true) method with the second parameter set to true instead of RegExp, returns an object containing three properties:∎lookbehind - is actuality a capturing group; is non empty group only with accuracy: 'exactly' or { 'value' : 'exactly', 'limiters': [..] }. It can be easily converted to real lookbehind by replacing the first ( by (?&lt;=.∎pattern - a string pattern∎lookahead - is real lookahead assertion pattern; is non empty string only with accuracy: 'exactly' or { 'value' : 'exactly', 'limiters': [..] }∎These properties can be used in options object: accuracy, diacritics, synonyms, caseSensitive, ignoreJoiners, ignorePunctuation, and wildcards. See mark() method for properties details.∎import RegExpCreator from './regexpcreator.es6.js'; const creator = new RegExpCreator(options); const obj = creator.create(string, true); console.log(obj.lookbehind, obj.pattern, obj.lookahead);∎The createCombinePattern(array, capture) method creates combine pattern from an array of string; returns an object containing three properties:∎lookbehind - is the same as in create() method;∎pattern - a combine pattern itself. If the capture parameter set to true, an individual string pattern is wrapped in a capturing group, false - non-capturing group.∎lookahead - is the same as in create() method;∎// the 'creator' and the accepted options are the same as in above example const obj = creator.createCombinePattern(array, true); console.log(obj.pattern); // true - (ptn1)|(ptn2)|(ptn3); false - (?:ptn1)|(?:ptn2)|(?:ptn3)∎The createDiacritics(string) method returns a string diacritic pattern. It's affected only by one option : caseSensitive.∎import creator from './regexpcreator.es6.js'; const pattern = new creator(options).createDiacritics(string); console.log(pattern);",8],
["Highlighting separate groups∎Important: in this implementation two branches of code process separate groups, which one, depending on the existence of d flag.∎Primitive, base on indexOf(), only reliable with contiguous groups - unwanted group(s) can be easily filtered out.∎Exact, but not all browsers currently supported group indices.∎Case without wrapAllRanges option:∎They both have identical logic for nested groups - if a parent group has been marked, there is no way to mark nested groups. This means you can use a nested group(s) as auxiliary and don't care about filtering them.∎Case wrapAllRanges : true:∎With acrossElements option, the primitive one wrap a whole match as a group 0 and then all groups that are child of match[0] as a nested (see Example).∎The exact one wrap all nested groups - you need to filter nested an auxiliary group(s).∎They have different parent groups logic:∎The exact one does allow using a parent group as an auxiliary - you need to filter out it in order to mark a nested group(s).∎The primitive one does not allow this - if a parent group has filtered out, a nested group(s) won't be marked.∎To test the primitive branch compatibility, just add the d flag.∎There is no strict requirement for the contiguity of capturing groups. Compare: string - 'AAB xxx BCD xx BC', to mark groups AB and BC∎in /(AB)\\b.+?\\b(BC)/g the indexOf('BC', start) find first 'BC', which is correct∎in /(AB)\\b(.+?)\\b(BC)(?!D)/g the indexOf('BC', start) also find first 'BC', which is wrong, because of condition '(?!D)', so group 2 is required.∎Warning: related using RegExp without the d flag:∎Do not add a capturing group(s) to lookbehind assertion (?&lt;=), there is no code which handles such cases.∎With acrossElements option, it is not possible to highlight a capturing group(s) inside a lookahead assertion (?=).∎See markRegExp() method about info object properties used in filter and each callbacks. How to filter matches see Filtering matches. How to highlight nesting groups see Nesting groups.∎Filtering capturing groups:∎instance.markRegExp(/(AB)\\b(.+)\\b(?&lt;gr3&gt;CD)?(.+)(EF)\\b/gi, { // 'acrossElements' : true, 'separateGroups' : true, 'filter' : (textNode, matchString, marksSoFar, info) =&gt; { // To filter any group use info.groupIndex - a current group index // Note: if a group lays across several elements, the index be the same while a group is wrapping if (info.groupIndex === 2 || info.groupIndex === 4) return false; // also can be used a group content // if (matchString === 'AB') return false; // To filter a whole match on a group presence // Note: it iterates through all groups and only then returns if (info.match[3]) return true/false; // or // also can be used a named capturing group if (info.match.groups.gr3) return true/false; return true; }, });∎Example to mark separate groups with acrossElements option:∎let groupCount = 0, gr1Count = 0, gr2Count = 0; instance.markRegExp(/(AB)\\b.+?\\b(CD)/gi, { 'acrossElements' : true, 'separateGroups' : true, 'each' : (markElement, info) =&gt; { // info.count - matches count so far // if start of match group if (info.groupStart) { // all group count groupCount++; // info.groupIndex is the index of a current match group if (info.groupIndex === 1) { markElement.className = 'group1-1'; gr1Count++; } else if (info.groupIndex === 2) { markElement.className = 'group2-1'; gr2Count++; } } } });∎Example to mark separate groups without acrossElements option:∎let count = 0, gr1Count = 0; instance.markRegExp(/(AB).+?(CD)/gi, { 'separateGroups' : true, 'each' : (markElement, info) =&gt; { // all group count count++; if (info.groupIndex === 1) { // an individual group count gr1Count++; } } });",9],
["Highlighting in shadow DOM∎With an option shadowDOM : true the advance-mark.js now is able to highlight inside shadow DOMs that have mode: 'open' and are already created. You can play with advance-mark.js-playground. Examples -&gt; Shadow DOM. Note: to style mark elements in shadow DOM, the option shadowDOM : {style : 'your mark element style'} can be used. It creates a style element and inserts it at the beginning of shadow root child node(s). But this operation is invasive, it can break the root code. An inline style can be used as an alternative:∎each : (markElement, info) =&gt; { // a shadow root is the DocumentFragment if (markElement.getRootNode().nodeType === Node.DOCUMENT_FRAGMENT_NODE) { markElement.style.color = &quot;red&quot;; } }",10],
["Code examples∎See mark() each callback and markRegExp() each callback about each callback info object properties.∎The mark() method code example with acrossElements option∎let matchCount = 0; instance.mark(['AB CD', 'EF'], { 'acrossElements' : true, 'each' : (markElement, info) =&gt; { // sets external counter matchCount = info.count; // internal use if (info.count ..) {} // if start of the match if(info.matchStart) { markElement.className = 'start-1'; // markElement.setAttribute('data-markjs', 'start-1'); // to use the attribute instead of class // matchCount++; // to use the custom counter instead of info.count } }, 'done' : (totalMarks, totalMatches, termStats) =&gt; { for (const term in termStats) { console.log(term + ' = ' + termStats[term]); } } });∎The mark() method code example without acrossElements option∎let matchCount = 0; context.mark('AB CD EF', { 'separateWordSearch' : true, 'each' : (markElement, info) =&gt; { // for external counter matchCount = info.count; // also possible matchCount++; // for internal use if(info.count ..) {} }, 'done' : (totalMarks, totalMatches, termStats) =&gt; { console.log('Total matches = ' + totalMatches); for(var term in termStats) { console.log(term + ' = ' + termStats[term]); } } });∎The markRegExp() method code example with acrossElements option∎let matchCount = 0; instance.markRegExp(/.../gi, { 'acrossElements' : true, 'each' : (markElement, info) =&gt; { // usage of info.count and custom counter are the same // as in mark() method with `acrossElements` option // use of info.count as a unique match identifier markElement.setAttribute('data-markjs', info.count); }, 'done' : (totalMarks, totalMatches) =&gt; { console.log('Total matches = ' + totalMatches); } });∎Simple example with next/previous buttons.∎Unusable with markRegExp() method having wrapAllRanges option. See Example with next/previous buttons that can be used for this case.∎let currentIndex = 0, marks = $('mark'), startElements = marks.filter((i, elem) =&gt; $(elem).hasClass('start-1')); //startElements = marks.filter((i, elem) =&gt; $(elem).data('markjs') === 'start-1'); prevButton.on('click', function() { if (--currentIndex &lt;= 0) currentIndex = 0; let elem = startElements.eq(currentIndex); if (elem.length) highlightMatch(elem[0]); }); nextButton.on('click', function() { if (++currentIndex &gt;= startElements.length) currentIndex = startElements.length - 1; let elem = startElements.eq(currentIndex); if (elem.length) highlightMatch(elem[0]); }); // adds class 'current' to all mark elements of the found match if it located across elements // or to the first mark element function highlightMatch(elem) { let found = false; marks.each((i, el) =&gt; { if ( !found) { if (el === elem[0]) found = true; // start of the next 'start element' means the end of the current match } else if ($(this).hasClass('start-1')) return false; //} else if ($(this).data('markjs') === 'start-1') return false; if (found){ $(this).addClass('current'); $(this).find('*[data-markjs]').addClass('current'); // add class to all descendant too } }); }",11],
["unmark() method∎Syntax∎// javascript const instance = new Mark(context); instance.unmark([options]); // jQuery $(context).unmark([options]);∎Parameters:∎options object - Optional options:∎Option∎Type∎Default∎Description∎element∎string∎mark∎Specifies marked elements to remove.∎Important: if other than default marked element is used, e.g. span, it must be also specified in the unmark() method. It is also possible to use * in case of using different marked elements to unmark in one run. A mark.js library uses a default selector *[data-markjs] but it is not safe to apply to all HTML elements.∎className∎string∎''∎Remove only marked elements with specified class name.∎exclude∎string or string[]∎[]∎A string or an array of selectors. Specifies DOM elements that should be excluded from searching.∎shadowDOM∎boolean∎undefined∎Whether to remove marked elements inside shadow DOMs∎Note: if the shadowDOM option is used with highlighting method, it must be also specified in the unmark() method. See Highlighting in shadow DOM for more details.∎iframes∎boolean∎false∎Whether to search inside iframes∎Note: if the iframes option is used with highlighting method, it must be also specified in the unmark() method.∎iframesTimeout∎number∎5000 ms∎The max time to wait for iframe(s) to load before skipping∎debug∎boolean∎false∎Whether to log messages∎log∎object∎console∎Log messages to a specific object∎done∎function∎A callback after all specified marked elements were removed done : () =&gt; {}∎It has no parameters.∎Example with default options values∎const options = { element : 'mark', className : '', shadowDOM : false, iframes : false, iframesTimeout : 5000, done : () =&gt; {}, debug : false, log : window.console };∎JavaScript:∎var instance = new Mark(document.querySelector('selector')); instance.unmark(options);∎jQuery:∎$('selector').unmark(options);",12],
];
var SearchIndex = {"elements":[0,15,3,11,5,11,12,7,4,4,6,2,11,2,2,1,7,1,9,1,10,1],"boundaries":[0,5,3,4,5,2,2,1],"with":[6,13,7,13,5,8,0,6,3,6,11,6,9,4,12,4,4,3,8,3,1,2,10,2],"acrosselements":[5,14,3,12,1,6,9,6,11,6,6,5,0,4,7,4],"option":[6,10,5,9,0,7,3,7,7,7,9,5,11,5,1,4,12,3,10,2,4,1,8,1],"advance":[0,2,10,2],"mark":[3,15,1,13,5,11,6,10,4,9,11,9,7,6,9,5,12,5,0,4,10,4,2,1,8,1],"js":[7,4,0,3,8,2,10,2,12,1],"aggregates":[0,1],"text":[3,5,5,4,0,3,4,3,6,3,7,2],"nodes":[0,3,6,3,7,2],"content":[0,1,2,1,5,1,9,1],"into":[0,2,3,2,6,1,7,1],"a":[9,20,3,19,5,12,4,10,7,8,6,7,0,5,8,5,12,5,10,2,11,1],"single":[7,6,0,1],"string":[3,18,5,14,8,9,4,8,0,5,12,5,6,2,7,1,9,1],"taking":[0,1],"account":[0,1],"html":[0,3,3,2,5,2,12,1],"if":[11,14,1,12,6,12,9,12,0,3,12,3,3,1,4,1,5,1,8,1,10,1],"block":[0,7,3,1,5,1],"element":[3,5,4,5,5,5,12,3,0,2,10,2,11,2],"divides":[0,2],"two":[0,2,3,2,5,1,6,1,7,1,9,1],"and":[3,12,6,8,5,7,9,5,7,4,4,3,8,3,10,2,11,2,0,1,1,1,2,1],"node":[3,4,5,3,4,2,10,2,0,1],"textcontents":[0,1],"doesn":[0,2,5,1,6,1],"t":[0,2,6,2,9,2,5,1,7,1],"separated":[0,1,3,1,5,1],"by":[8,3,0,1,3,1,5,1,7,1],"white":[3,3,0,1],"space":[3,4,0,2],"the":[3,39,5,39,6,25,4,16,9,14,0,13,1,12,11,12,8,11,7,7,12,6,10,5],"is":[3,10,6,9,9,9,0,8,5,8,8,7,12,5,4,4,7,3,10,3,1,1],"added":[0,4,3,2,5,2,6,2,4,1],"to":[3,20,5,18,6,15,9,14,12,11,4,9,1,8,0,6,7,6,11,5,8,3,10,2],"separate":[9,4,0,2,2,1,3,1,5,1],"them":[0,2,9,1],"e":[3,5,5,3,6,3,0,2,7,2,4,1,12,1],"g":[5,10,3,5,6,4,0,2,7,2,9,2,4,1,12,1],"header":[0,4],"paragraph":[0,3],"resulted":[0,1],"in":[12,6,6,5,8,5,9,5,1,3,3,3,11,3,0,2,5,2,7,2,10,2,2,1,4,1],"headerparagraph":[0,1],"but":[0,1,3,1,6,1,7,1,9,1,10,1,12,1],"knows":[0,1],"any":[3,4,6,3,0,1,7,1,9,1],"blockelementsboundary":[0,8,3,2,5,2],"invented":[0,1],"limit":[0,1,3,1,5,1],"matches":[3,9,1,8,5,6,6,3,9,3,0,2,11,2,2,1,4,1],"within":[0,1,3,1,5,1,6,1],"it":[5,7,12,6,6,5,7,5,3,3,8,3,9,3,10,3,0,2,4,2,1,1,11,1],"allows":[0,1],"only":[0,5,5,5,1,4,6,3,8,3,3,2,7,2,9,2,12,1],"across":[3,2,5,2,0,1,4,1,9,1,11,1],"inline":[0,1,10,1],"true":[6,15,1,13,3,12,9,9,5,8,8,6,0,5,11,4,7,3,4,2,10,1],"character":[3,9,0,2,5,1],"spaces":[0,1,3,1,5,1],"depend":[0,1],"between":[1,4,0,1],"above":[5,2,0,1,7,1,8,1],"combined":[7,2,0,1],"becomes":[0,1],"custom":[0,9,3,7,5,6,11,2,4,1],"tagnames":[0,4,3,1,5,1],"are":[3,4,6,4,0,3,5,3,7,2,8,1,9,1,10,1,11,1],"defined":[0,1],"they":[0,2,9,2,6,1],"can":[6,7,9,4,10,4,0,2,3,2,7,2,8,2,1,1,5,1,11,1],"be":[3,5,9,5,5,4,6,4,12,4,0,2,4,2,7,2,8,2,10,2,11,1],"that":[5,5,3,4,4,2,0,1,6,1,9,1,10,1,11,1,12,1],"have":[0,3,5,2,9,2,1,1,3,1,6,1,10,1],"default":[0,10,3,7,5,5,12,4,4,2,7,1],"makes":[0,1],"sense":[0,1],"when":[5,6,3,5,0,1,6,1],"highlighting":[12,3,2,2,5,2,7,2,0,1,3,1,4,1,9,1,10,1],"phrases":[0,1],"or":[3,18,5,7,0,5,4,4,7,3,8,2,12,2,9,1,11,1],"regexp":[5,8,6,3,1,2,3,2,0,1,7,1,8,1,9,1],"groups":[6,17,9,17,5,5,1,2,2,2,4,2,0,1],"using":[9,2,0,1,1,1,12,1],"wildcards":[3,3,0,2,8,1],"withspaces":[0,1,3,1],"boolean":[3,15,5,12,4,5,12,3,0,1],"object":[3,16,5,10,4,9,8,3,12,3,0,2,1,2,6,1,9,1,11,1],"undefined":[3,3,5,3,0,2,4,2,12,1],"array":[3,9,7,8,5,4,8,3,4,2,0,1,6,1,12,1],"of":[3,25,5,23,4,8,11,8,9,7,7,6,6,4,1,2,8,2,12,2,0,1,10,1],"tag":[0,2,3,1,5,1],"name":[0,1,12,1],"extend":[0,3,3,1,5,1],"whether":[3,9,5,6,4,3,12,3,0,1],"specify":[0,1],"false":[3,18,5,14,1,8,4,7,12,5,9,4,6,3,11,3,0,2,8,2,7,1],"char":[0,4,3,1,5,1],"boundary":[3,4,5,3,0,2],"instance":[6,8,1,4,3,4,4,4,5,4,12,4,9,3,11,2,0,1,7,1],"lorem":[0,1],"ipsum":[0,1],"dolor":[0,1],"separatewordsearch":[3,2,0,1,7,1,11,1],"these":[0,1,8,1],"div":[0,2],"p":[0,2],"optional":[0,2,3,1,4,1,5,1,12,1],"extending":[0,1],"context":[3,4,5,3,4,2,6,2,12,2,0,1,11,1],"markregexp":[5,5,6,5,1,4,9,4,11,4,0,1,2,1,7,1],"gi":[9,3,1,2,0,1,5,1,11,1],"tab":[0,1],"container":[0,1],"address":[0,1],"area":[0,1],"article":[0,1],"aside":[0,1],"audio":[0,1],"blockquote":[0,1],"body":[0,1],"br":[0,1],"button":[0,1],"canvas":[0,1],"dd":[0,1],"details":[3,4,5,4,4,2,0,1,8,1,12,1],"dl":[0,1],"dt":[0,1],"fieldset":[0,1],"figcaption":[0,1],"figure":[0,1],"footer":[0,1],"form":[0,1],"hr":[0,1],"iframe":[0,1,3,1,4,1,5,1,12,1],"img":[0,1],"input":[0,1],"label":[0,1],"li":[0,1],"main":[0,1,6,1],"map":[0,1],"menu":[0,1],"menuitem":[0,1],"meter":[0,1],"nav":[0,1],"ol":[0,1],"output":[0,1],"picture":[0,1],"pre":[0,1],"section":[0,1],"select":[0,1],"svg":[0,1],"table":[0,1],"tbody":[0,1],"td":[0,1],"textarea":[0,1],"tfoot":[0,1],"th":[0,1],"thead":[0,1],"tr":[0,1],"track":[0,1],"ul":[0,1],"video":[0,1],"filtering":[9,3,1,2,2,1],"see":[3,4,5,4,9,4,1,2,4,2,11,2,8,1,12,1],"filter":[1,13,9,7,3,4,4,4,5,4,6,3,11,2],"callback":[1,7,3,4,4,4,5,4,11,3,12,1],"about":[9,2,1,1,11,1],"info":[6,17,1,15,9,15,11,13,10,1],"properties":[8,4,3,3,5,2,6,2,1,1,4,1,9,1,11,1],"capturing":[9,5,5,3,6,3,8,3,1,2,4,1],"method":[8,6,12,6,11,5,2,4,3,4,5,4,1,3,7,3,6,2,4,1,9,1],"let":[6,7,11,7,1,4,9,2],"count":[1,17,11,8,9,7,3,3,5,2,6,2,4,1],"ab":[9,7,1,2,11,2],"textnode":[1,3,3,3,4,3,5,3,6,1,9,1],"term":[3,13,11,6,1,2],"markssofar":[1,3,3,3,5,3,6,1,9,1],"termmarkssofar":[3,3,1,2],"first":[1,7,6,2,9,2,8,1,11,1],"match":[3,18,5,17,6,13,9,7,1,5,11,4,2,1,4,1],"execution":[1,7,3,3,5,3],"abort":[1,7,3,2,5,2],"return":[1,12,9,5,3,2,4,2,5,2,6,2,11,2],"requires":[1,2],"its":[1,2],"own":[1,2],"counter":[11,4,1,3],"matchstart":[3,4,5,4,1,2,4,1,6,1,11,1],"skip":[1,2],"else":[1,2,11,2,9,1],"without":[6,4,5,3,9,3,7,2,1,1,11,1],"difference":[1,1],"implementation":[1,1,9,1],"reg":[1,7],"you":[9,3,1,2,6,2,10,1],"access":[1,1],"also":[12,4,9,3,1,1,7,1,11,1],"used":[9,3,12,3,3,2,10,2,1,1,6,1,7,1,8,1,11,1],"lastindex":[1,3,5,1],"infinity":[1,3,7,3],"instead":[11,2,1,1,5,1,7,1,8,1],"matchstring":[5,3,4,2,9,2,1,1],"desired":[1,1],"number":[3,14,5,14,4,8,7,3,1,1,6,1,12,1],"on":[3,3,5,3,9,3,4,2,7,2,11,2,1,1],"each":[3,7,11,7,4,6,5,6,6,6,9,3,1,2,10,1],"s":[6,9,9,7,3,3,5,2,7,2,1,1,4,1,8,1,10,1,12,1],"much":[1,1],"more":[3,6,5,4,4,2,1,1,6,1,7,1,12,1],"limited":[1,1],"than":[1,1,7,1,12,1],"markelement":[6,10,11,6,9,4,3,3,4,3,5,3,10,3,1,1],"markranges":[4,5,6,3,2,1,7,1],"unmark":[12,9,2,1],"nesting":[6,8,4,2,5,2,9,2,2,1],"overlapping":[6,8,4,2,5,2,2,1],"ranges":[6,14,4,9,2,1,5,1,7,1],"shadow":[10,6,3,2,4,2,5,2,12,2,2,1],"dom":[3,3,4,3,5,3,10,3,12,2,2,1],"code":[11,4,9,2,2,1,6,1,7,1,10,1],"examples":[2,1,6,1,10,1,11,1],"performance":[7,7,3,3,2,1,6,1],"regexpcreator":[8,5,2,1],"module":[2,1,8,1],"syntax":[3,1,4,1,5,1,12,1],"javascript":[3,2,4,2,5,2,12,2],"const":[8,4,4,3,5,3,3,2,6,2,12,2,11,1],"new":[3,2,4,2,5,2,8,2,12,2],"search":[3,6,5,1,12,1],"options":[5,16,3,12,4,8,12,8,7,4,8,4,6,1],"jquery":[3,2,4,2,5,2,12,2],"parameters":[12,2,3,1,4,1,5,1],"strings":[3,2,7,2,5,1],"type":[4,2,3,1,5,1,12,1],"description":[3,1,4,1,5,1,12,1],"span":[3,1,4,1,5,1,12,1],"classname":[6,3,3,2,4,2,5,2,9,2,12,2,11,1],"class":[11,3,6,2,3,1,4,1,5,1,12,1],"exclude":[3,2,4,2,5,2,12,1],"an":[3,10,7,5,8,4,9,3,10,3,4,2,5,2,6,2,12,1],"selectors":[3,1,4,1,5,1,12,1],"specifies":[12,2,3,1,4,1,5,1],"should":[5,2,6,2,3,1,4,1,12,1],"excluded":[3,1,4,1,5,1,12,1],"from":[8,3,5,2,6,2,3,1,4,1,12,1],"searching":[3,3,4,1,5,1,12,1],"break":[3,1,6,1,10,1],"words":[7,4,3,3,6,1],"for":[3,13,5,11,4,6,11,5,9,2,12,2,6,1,7,1,8,1],"individual":[3,3,8,1,9,1],"word":[3,4,6,4],"diacritics":[7,3,3,2,8,1],"diacritic":[3,1,8,1],"characters":[3,7],"casesensitive":[3,2,8,2],"case":[6,3,9,2,3,1,11,1,12,1],"sensitive":[3,1],"accuracy":[3,3,8,3],"partially":[3,3],"either":[3,2,4,1,5,1],"one":[3,6,9,5,6,1,8,1,12,1],"following":[3,1],"value":[3,4,8,2],"back":[3,2],"visa":[3,2],"exactly":[8,4,3,3],"this":[7,6,6,5,11,5,9,3,3,1,5,1,10,1],"actually":[3,1],"forced":[3,1],"use":[11,5,9,2,3,1,12,1],"because":[6,2,3,1,9,1],"start":[11,9,3,5,5,5,4,4,6,4,9,3],"end":[3,2,11,1],"complementary":[3,2],"whole":[5,2,9,2,3,1,6,1],"whitespaces":[3,1],"_":[3,1],"bject":[3,1],"limiters":[3,2,8,2],"split":[3,1],"disabled":[3,3],"as":[6,4,9,4,3,3,8,3,11,2,7,1,10,1],"unless":[3,1],"thay":[3,1],"escaped":[3,1],"itself":[3,1,8,1],"enabled":[3,1],"non":[3,3,8,3,4,1],"zero":[3,7],"time":[3,3,4,1,5,1,12,1],"times":[3,3,7,1],"few":[3,1],"possible":[3,1,6,1,9,1,11,1,12,1],"ignorejoiners":[3,2,8,1],"find":[9,2,3,1,6,1,11,1],"contain":[3,1],"soft":[3,1],"hyphen":[3,1],"width":[3,3],"joiner":[3,2],"ignorepunctuation":[3,2,8,1],"punctuation":[3,1],"synonyms":[3,3,8,1],"synonym":[3,1],"vice":[3,1],"versa":[3,1],"am":[3,1],"combinepatterns":[7,7,3,3],"combine":[8,2,3,1,7,1],"specified":[12,5,3,1],"patterns":[7,4,3,1],"cachetextnodes":[7,3,3,2],"caching":[3,1,7,1],"information":[7,2,3,1],"improve":[3,1,7,1],"names":[3,1,5,1],"extends":[3,1,5,1],"otherwise":[3,1,5,1,6,1],"do":[3,1,5,1,9,1],"shadowdom":[12,3,3,2,4,2,5,2,10,2],"inside":[3,2,4,2,5,2,12,2,6,1,7,1,9,1,10,1],"doms":[3,1,4,1,5,1,10,1,12,1],"iframes":[12,4,3,3,4,3,5,3],"iframestimeout":[3,2,4,2,5,2,12,2],"ms":[7,24,6,4,3,1,4,1,5,1,12,1],"max":[3,1,4,1,5,1,12,1],"wait":[3,1,4,1,5,1,12,1],"load":[3,1,4,1,5,1,12,1],"before":[3,1,4,1,5,1,12,1],"skipping":[3,1,4,1,5,1,12,1],"debug":[3,2,4,2,5,2,12,2],"log":[3,4,4,4,5,4,11,4,12,4,8,3],"messages":[3,2,4,2,5,2,12,2],"console":[11,4,8,3,3,2,4,2,5,2,12,2],"specific":[3,1,4,1,5,1,12,1],"function":[3,4,4,4,5,4,6,4,11,3,12,1],"calls":[3,2,4,2,5,2],"located":[3,1,4,1,5,1,11,1],"several":[3,1,4,1,5,1,9,1],"which":[9,4,3,2,4,2,5,2,6,2],"part":[3,2,4,2,5,2],"filterinfo":[3,4,5,4],"includes":[3,1,4,1,5,1],"current":[6,4,11,4,4,3,5,3,3,2,9,2],"all":[6,6,9,6,3,2,11,2,12,2,5,1],"wrapped":[6,7,3,2,4,1,5,1,8,1],"so":[3,4,5,3,9,2,4,1,7,1],"far":[3,4,5,3,4,1,9,1],"result":[3,2,5,2],"exec":[3,2,5,2],"indicate":[5,3,3,2,4,1],"ae":[5,5,3,3],"helper":[3,1,5,1],"early":[3,1,5,1],"setting":[3,1,5,1],"breaks":[3,1,5,1],"offset":[3,2,5,2,6,2],"absolute":[3,1,5,1,6,1],"index":[4,4,5,3,9,3,6,2,3,1],"joined":[3,1,5,1],"sum":[3,1,5,1],"lengths":[3,1,5,1],"were":[3,1,5,1,12,1],"composite":[3,1,5,1],"marked":[12,6,6,4,3,3,4,3,5,3,7,3,9,2],"eachinfo":[3,4,5,4],"htmlelement":[3,1,4,1,5,1],"done":[3,3,4,3,5,3,11,3,12,3,6,1],"finish":[3,1,4,1,5,1],"totalmarks":[3,3,4,3,5,3,11,3,6,1],"totalmatches":[11,5,3,3,5,3,6,2,4,1],"termstats":[11,6,3,3],"total":[3,2,4,2,5,2,11,2],"containing":[6,2,8,2,3,1,7,1],"nomatch":[3,3,4,3,5,3],"called":[3,1,4,1,5,1],"has":[9,2,3,1,6,1,12,1],"no":[9,3,3,1,12,1],"at":[3,1,10,1],"not":[9,4,6,2,3,1,7,1,12,1],"found":[11,5,3,1],"parameter":[8,2,3,1],"available":[5,5,3,3],"depending":[3,2,5,2,9,1],"example":[11,5,9,3,6,2,3,1,4,1,5,1,8,1,12,1],"values":[4,2,3,1,5,1,12,1],"must":[12,3,5,2,3,1,4,1],"window":[3,1,4,1,5,1,12,1],"var":[3,1,11,1,12,1],"document":[3,1,4,1,5,1,12,1],"queryselector":[3,1,4,1,5,1,12,1],"selector":[12,3,3,2,4,2,5,2],"test":[3,2,9,1],"set":[5,3,8,2,3,1],"objects":[4,1,6,1],"length":[6,5,11,4,4,3,7,1],"integer":[4,1],"wrapallranges":[6,12,4,2,5,2,9,2,11,1],"marking":[4,1,5,1,7,1],"range":[4,21,6,7],"matching":[5,4,4,1],"rangeinfo":[4,3],"totalranges":[4,2],"valid":[4,1],"stringify":[4,1,5,1],"matchingstring":[4,1],"regex":[5,10,6,10],"regular":[5,1],"expression":[5,1],"flag":[6,6,5,5,9,3],"works":[5,1],"indexes":[5,1,6,1],"y":[5,1],"flags":[5,1],"allow":[9,2,5,1],"control":[5,1],"note":[6,2,7,2,9,2,12,2,5,1,10,1],"backward":[5,1],"compatibility":[5,1,9,1],"recompile":[5,1],"internally":[5,1],"although":[5,1],"require":[5,1,6,1],"still":[5,1],"recommended":[5,1],"having":[6,2,5,1,11,1],"ignoregroups":[5,7],"contiguous":[5,1,9,1],"ignored":[6,3,5,1],"w":[6,8,5,3],"group":[9,25,6,13,5,7,8,4],"separategroups":[5,9,6,5,9,3],"groupindex":[9,7,5,4,6,3],"sg":[5,5],"groupstart":[5,2,6,2,9,1],"failed":[5,1],"both":[5,1,9,1],"d":[6,9,9,5],"positive":[6,1],"lookaround":[6,3],"assertions":[6,2],"practically":[6,1],"removes":[6,1],"restrictions":[6,1],"demonstrate":[6,1],"cases":[6,1,9,1],"won":[6,1,9,1],"correctly":[6,2],"highlighted":[6,2,7,2],"create":[8,5,6,1,7,1],"b":[9,9,6,1],"dg":[6,5],"second":[7,3,6,1,8,1],"already":[6,1,7,1,10,1],"another":[6,1],"order":[6,3,9,1],"overlap":[6,1],"cause":[6,1],"degradation":[6,1],"contains":[6,1],"very":[6,1],"large":[7,2,6,1],"wrapping":[6,1,9,1],"inserted":[6,1],"lot":[6,1],"copying":[6,1],"memory":[6,1],"allocation":[6,1],"file":[6,2],"sec":[6,4,7,4],"wraps":[6,1],"regardless":[6,1],"nested":[6,12,9,8],"level":[6,1],"need":[9,2,6,1],"out":[9,3,6,1],"unwanted":[6,1,9,1],"been":[6,1,9,1],"distinguish":[6,1],"add":[6,2,9,2,11,1],"some":[6,2],"property":[6,1],"way":[6,1,9,1],"through":[6,1,9,1],"hack":[6,1],"buildranges":[6,2],"handle":[6,1],"additional":[6,2],"setattribute":[6,2,11,2],"data":[11,5,6,4,12,1],"markjs":[11,5,6,4,12,1],"id":[6,1],"build":[6,1],"attempt":[6,1],"normal":[6,1],"workflow":[6,1],"i":[6,7,11,3],"skips":[6,1],"indices":[6,5,9,1],"translate":[6,1],"local":[6,1],"color":[6,1,10,1],"highlight":[6,3,9,2,10,1],"identifer":[6,1],"next":[6,3,11,3],"previous":[6,3,11,2],"buttons":[6,3,11,2],"here":[6,1],"push":[6,1],"simple":[6,1,11,1],"uses":[6,2,12,1],"numbers":[6,1,7,1],"unique":[6,1,11,1],"identifiers":[6,1],"continuous":[6,1],"ascending":[6,1],"work":[6,1],"currentindex":[11,7,6,6],"matchcount":[11,7,6,4],"marks":[6,4,11,4],"sentences":[6,1],"dgi":[6,1],"identifier":[6,1,11,1],"prevbutton":[6,1,11,1],"click":[6,2,11,2],"highlightmatchgroups":[6,3],"nextbutton":[6,1,11,1],"removeclass":[6,1],"elems":[6,2],"elem":[11,12,6,2],"addclass":[6,2,11,2],"descendant":[6,1,11,1],"too":[6,1,11,1],"results":[7,1],"firefox":[7,2],"compare":[7,1,9,1],"library":[7,3,12,1],"size":[7,12],"same":[8,3,7,2,9,1,11,1],"ways":[7,1],"boost":[7,2],"related":[7,2,9,1],"especially":[7,1],"highlights":[7,1],"item":[7,2],"items":[7,3],"run":[7,2,12,1],"isn":[7,1],"efficient":[7,1],"there":[9,3,7,2],"combines":[7,1],"given":[7,1],"pattern":[8,12,7,6],"creates":[7,2,8,1,10,1],"runs":[7,2],"bigger":[7,1],"monstrous":[7,1],"slowly":[7,1],"better":[7,1],"probably":[7,1],"processor":[7,1],"cache":[7,1],"prevents":[7,1],"collecting":[7,1],"every":[7,1],"expensive":[7,1],"improves":[7,1],"gain":[7,1],"gradually":[7,1],"grows":[7,1],"starting":[7,1],"doubled":[7,1],"does":[7,2,9,2],"change":[7,1],"behavior":[7,1],"existing":[7,1],"mb":[7,1],"page":[7,1],"exposes":[8,1],"three":[8,3],"api":[8,1],"createcombinepattern":[8,3],"creatediacritics":[8,3],"methods":[8,1],"returns":[8,3,9,1],"lookbehind":[8,4,9,1],"actuality":[8,1],"empty":[8,2],"easily":[8,1,9,1],"converted":[8,1],"real":[8,2],"replacing":[8,1],"lookahead":[8,4,9,1],"assertion":[9,2,8,1],"import":[8,2],"creator":[8,6],"obj":[8,6],"capture":[8,2],"accepted":[8,1],"affected":[8,1],"important":[9,1,12,1],"branches":[9,1],"process":[9,1],"existence":[9,1],"primitive":[9,4],"base":[9,1],"indexof":[9,3],"reliable":[9,1],"filtered":[9,2],"exact":[9,3],"browsers":[9,1],"currently":[9,1],"supported":[9,1],"identical":[9,1],"logic":[9,2],"parent":[9,4],"means":[9,1,11,1],"auxiliary":[9,3],"don":[9,1],"care":[9,1],"wrap":[9,2],"then":[9,2],"child":[9,1,10,1],"different":[9,1,12,1],"branch":[9,1],"just":[9,1],"strict":[9,1],"requirement":[9,1],"contiguity":[9,1],"aab":[9,1],"xxx":[9,1],"bcd":[9,1],"xx":[9,1],"bc":[9,8],"correct":[9,1],"wrong":[9,1],"condition":[9,1],"required":[9,1],"warning":[9,1],"handles":[9,1],"such":[9,1],"callbacks":[9,1],"how":[9,2],"cd":[9,3,11,2],"ef":[11,2,9,1],"lays":[9,1],"while":[9,1],"presence":[9,1],"iterates":[9,1],"named":[9,1],"groupcount":[9,2],"now":[10,1],"able":[10,1],"mode":[10,1],"open":[10,1],"created":[10,1],"play":[10,1],"playground":[10,1],"style":[10,6],"your":[10,1],"inserts":[10,1],"beginning":[10,1],"root":[10,3],"operation":[10,1],"invasive":[10,1],"alternative":[10,1],"documentfragment":[10,1],"getrootnode":[10,1],"nodetype":[10,1],"document_fragment_node":[10,1],"red":[10,1],"sets":[11,1],"external":[11,2],"internal":[11,2],"attribute":[11,1],"usage":[11,1],"unusable":[11,1],"startelements":[11,6],"hasclass":[11,2],"eq":[11,2],"highlightmatch":[11,3],"adds":[11,1],"el":[11,2],"remove":[12,3],"other":[12,1],"safe":[12,1],"apply":[12,1],"after":[12,1],"removed":[12,1]};
